//This source code is generated by UI Designer Studio.

#include "UIFramework.h"
#include "UIFrameworkExt.h"
#include "NVTToolCommand.h"
#include "UIFlowWndMovieRes.c"
#include "UIFlow.h"
#include "Audio.h"
#include "FileSysTsk.h"
#include "UIAppPlay.h"
//#include "ImageApp_Movie.h"
#include "ImageApp_MovieMulti.h"
#include "ImageApp_Photo.h" //for NVTEVT_CALLBACK, NVTEVT_CB_ZOOM, NVTEVT_ALGMSG_PREVIEW_STABLE
#if (CALIBRATION_FUNC == ENABLE)
#include "EngineerMode.h"
#include "calibration_item.h"
#endif
#include "DxOutput.h"
#include    "stdio.h"
#include    "GPS.h"
#if(USER_WATCH_DOG==ENABLE)
#include "wdt.h"
#endif
#if USE_FILEDB
#include "FileDB.h"
#include "NameRule_FileDB.h"
#endif
#include "UIFlow.h"
#if !defined(_GSensor_None_)
#include "GSensor.h"
#endif
#include "display.h"

#if (LOG_DBGINFO_IN_GPS_SECTION == ENABLE)
#include "mp4log.h"
#endif  // #if (LOG_DBGINFO_IN_GPS_SECTION == ENABLE)
#include "alg_UIFlowWndMovie.h"
#include "alg_MovieExe.h"
#include "media_def.h"
#include "MovieInterface.h"
#include "UIAppPhoto.h"
#if( defined(_NVT_ETHREARCAM_RX_))
#include "EthCamAppSocket.h"
#include "EthCamAppNetwork.h"
#endif
#include "UsbDevDef.h"
#if( defined(_NVT_ETHREARCAM_TX_) && AV_LCA_FUNC == ENABLE)
#include "av_lca_lib.h"
#endif

#include "rtc.h"
#include "HwClock.h"
#include "UISetup.h"

#include "UIInfo.h"
#include "gpio.h"
#include "gpio_info.h"
#define __MODULE__          UIFlowWndMovie
//#define __DBGLVL__ 0        //OFF mode, show nothing
#define __DBGLVL__ 1        //ERROR mode, show err, wrn only
//#define __DBGLVL__ 2        //TRACE mode, show err, wrn, ind, msg and func and ind, msg and func can be filtering by __DBGFLT__ settings
#define __DBGFLT__ "*"      // *=All
#include "DebugModule.h"

//#NT#2016/09/29#KCHong -begin
//#NT#The GPS related variables should not depend on ADAS.
#if (GPS_FUNCTION == ENABLE)
extern FLOAT g_CurSpeed;
extern BOOL g_GPSLinked;
extern BOOL g_GPSStatus;
#endif
//#NT#2016/09/29#KCHong -end

//#NT#2016/09/20#Bob Huang -begin
//#NT#Support HDMI Display with 3DNR Out
#if (_3DNROUT_FUNC == ENABLE)
extern BOOL     gb3DNROut;
#endif
//#NT#2016/09/20#Bob Huang -end
BOOL gWifiAutoRec = FALSE;
//static BOOL gDelayLock = FALSE;
static BOOL gDelayCrash = FALSE;
//static BOOL gDelayEMR = FALSE;
extern BOOL gbNoNeedVocieNotice;
//static BOOL bDelayOpenWifi = FALSE;
extern BOOL g_wifi_info_show;
BOOL bEnterTimelapse = FALSE;
BOOL  g_bRecordLock = FALSE;
extern BOOL bDemoStart;

#define MODE_MOVIE 		0
#define MODE_PHOTO 		1
#define MODE_PLAYBACK 	2
#define MODE_CUSTOM	    3
UINT32 curmode = MODE_MOVIE;

extern void System_ChangeToWifiMode(void);
extern BOOL System_GetGsensorPwrOn(void);
extern void System_SetParkPwroffTimeCount(INT32 iValue);

//---------------------UIFlowWndMovieCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie)
CTRL_LIST_ITEM(UIFlowWndMovie_Panel_Normal_Display)
CTRL_LIST_ITEM(UIFlowWndMovie_ADAS_Alert_Display)
CTRL_LIST_END

//----------------------UIFlowWndMovieCtrl Event---------------------------
INT32 UIFlowWndMovie_OnOpen(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnUpdateInfo(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyNext(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeySelect(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyMenu(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyEnter(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyDown(VControl *, UINT32, UINT32 *);
//INT32 UIFlowWndMovie_OnKeyRight(VControl *, UINT32, UINT32 *);
//INT32 UIFlowWndMovie_OnKeyLeft(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnChildClose(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyShutter2(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyZoomin(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyZoomout(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyUp(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyPlayBack(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnBattery(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnBatteryLow(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyMode(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyCustom1(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyLock(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnKeyCapture(VControl *, UINT32, UINT32 *);

INT32 UIFlowWndMovie_OnMovieFinish(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieOneSec(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieFull(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnMovieWrError(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageSlow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray);
INT32 UIFlowWndMovie_OnLoopRecFull(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnEMRCompleted(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnPreviewStable(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnOZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnDZoomStepChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageInit(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnStorageChange(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnTimer(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnACPlug(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnACUnplug(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnCustom1(VControl *, UINT32, UINT32 *);
INT32 UIFlowWndMovie_OnADASShowAlarm(VControl *, UINT32, UINT32 *);        //#NT#2016/03/25#New ADAS#KCHong
//#NT#2016/06/23#Niven Cho -begin
//#NT#Enter calibration by cgi event or command event
INT32 UIFlowWndMovie_OnKeyCalibration(VControl *, UINT32, UINT32 *);
//#NT#2016/06/23#Niven Cho -end
//#NT#2016/07/20#Brain Yen -begin
//#NT#Add for DDD alarm
INT32 UIFlowWndMovie_OnDDDShowAlarm(VControl *, UINT32, UINT32 *);
//#NT#2016/07/20#Brain Yen -end
INT32 UIFlowWndMovie_OnOverTime(VControl *, UINT32, UINT32 *);
#if (WIFI_UI_DIRECT_MOBILE_LINKOK == ENABLE)
INT32 UIFlowWndMovie_OnWifiAuthorizeOK(VControl *, UINT32 , UINT32 *);
#endif
INT32 UIFlowWndMovie_OnMovieFileOK(VControl *, UINT32 , UINT32 *);
INT32 UIFlowWndMovie_OnBackgroundDone(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray);
INT32 UIFlowWndMovie_OnEnterAccOffTimelapse(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray);
INT32 UIFlowWndMovie_OnExitAccOffTimelapse(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray);

EVENT_BEGIN(UIFlowWndMovie)
EVENT_ITEM(NVTEVT_OPEN_WINDOW, UIFlowWndMovie_OnOpen)
EVENT_ITEM(NVTEVT_CLOSE_WINDOW, UIFlowWndMovie_OnClose)
EVENT_ITEM(NVTEVT_UPDATE_INFO, UIFlowWndMovie_OnUpdateInfo)
#if defined(_KEY_METHOD_4KEY_)
EVENT_ITEM(NVTEVT_KEY_NEXT, UIFlowWndMovie_OnKeyDown)    // Down Key
EVENT_ITEM(NVTEVT_KEY_SELECT, UIFlowWndMovie_OnKeyNext)    // OK Key
EVENT_ITEM(NVTEVT_KEY_SHUTTER2, UIFlowWndMovie_OnKeySelect)   // REC key
#else
EVENT_ITEM(NVTEVT_KEY_NEXT, UIFlowWndMovie_OnKeyNext)       // Right Key
EVENT_ITEM(NVTEVT_KEY_SELECT, UIFlowWndMovie_OnKeySelect)   // Enter key
#endif
EVENT_ITEM(NVTEVT_KEY_MENU, UIFlowWndMovie_OnKeyMenu)
EVENT_ITEM(NVTEVT_KEY_ENTER,UIFlowWndMovie_OnKeyEnter)
EVENT_ITEM(NVTEVT_KEY_MODE, UIFlowWndMovie_OnKeyMode)

EVENT_ITEM(NVTEVT_KEY_DOWN, UIFlowWndMovie_OnKeyDown)
//EVENT_ITEM(NVTEVT_KEY_LEFT,UIFlowWndMovie_OnKeyLeft)
//EVENT_ITEM(NVTEVT_KEY_RIGHT,UIFlowWndMovie_OnKeyRight)
EVENT_ITEM(NVTEVT_CHILD_CLOSE, UIFlowWndMovie_OnChildClose)
EVENT_ITEM(NVTEVT_KEY_SHUTTER2, UIFlowWndMovie_OnKeyShutter2)
EVENT_ITEM(NVTEVT_KEY_ZOOMIN, UIFlowWndMovie_OnKeyZoomin)
EVENT_ITEM(NVTEVT_KEY_ZOOMOUT, UIFlowWndMovie_OnKeyZoomout)
EVENT_ITEM(NVTEVT_KEY_UP, UIFlowWndMovie_OnKeyUp)
EVENT_ITEM(NVTEVT_KEY_PLAYBACK, UIFlowWndMovie_OnKeyPlayBack)
EVENT_ITEM(NVTEVT_BATTERY, UIFlowWndMovie_OnBattery)
EVENT_ITEM(NVTEVT_BATTERY_LOW, UIFlowWndMovie_OnBatteryLow)
EVENT_ITEM(NVTEVT_KEY_MODE, UIFlowWndMovie_OnKeyMode)
EVENT_ITEM(NVTEVT_KEY_CUSTOM1, UIFlowWndMovie_OnKeyCustom1)
EVENT_ITEM(NVTEVT_KEY_LOCK, UIFlowWndMovie_OnKeyLock)
EVENT_ITEM(NVTEVT_KEY_CAPTURE, UIFlowWndMovie_OnKeyCapture)
//EVENT_ITEM(NVTEVT_CB_MOVIE_FILE_OK, UIFlowWndMovie_OnMovieFileOK)	
EVENT_ITEM(NVTEVT_CB_MOVIE_REC_FINISH, UIFlowWndMovie_OnMovieFinish)
EVENT_ITEM(NVTEVT_CB_MOVIE_REC_ONE_SEC, UIFlowWndMovie_OnMovieOneSec)
EVENT_ITEM(NVTEVT_CB_MOVIE_OVERTIME, UIFlowWndMovie_OnOverTime) //file in BsMuxer not biggrer than 30mins, so callback BSMUXER_CBEVENT_OVERTIME to project, for re-rec
EVENT_ITEM(NVTEVT_CB_MOVIE_FULL, UIFlowWndMovie_OnMovieFull)
EVENT_ITEM(NVTEVT_CB_MOVIE_WR_ERROR, UIFlowWndMovie_OnMovieWrError)
EVENT_ITEM(NVTEVT_CB_MOVIE_SLOW, UIFlowWndMovie_OnStorageSlow)
EVENT_ITEM(NVTEVT_CB_MOVIE_LOOPREC_FULL, UIFlowWndMovie_OnLoopRecFull)
EVENT_ITEM(NVTEVT_CB_EMR_COMPLETED, UIFlowWndMovie_OnEMRCompleted)
//EVENT_ITEM(IPL_CBMSG_PREVIEWSTABLE,UIFlowWndMovie_OnPreviewStable)
EVENT_ITEM(NVTEVT_CALLBACK, UIFlowWndMovie_OnPreviewStable)
EVENT_ITEM(NVTEVT_CB_OZOOMSTEPCHG, UIFlowWndMovie_OnOZoomStepChange)
EVENT_ITEM(NVTEVT_CB_ZOOM, UIFlowWndMovie_OnDZoomStepChange)
EVENT_ITEM(NVTEVT_STORAGE_INIT, UIFlowWndMovie_OnStorageInit)
EVENT_ITEM(NVTEVT_STORAGE_CHANGE, UIFlowWndMovie_OnStorageChange)
EVENT_ITEM(NVTEVT_TIMER, UIFlowWndMovie_OnTimer)
EVENT_ITEM(NVTEVT_AC_Plug, UIFlowWndMovie_OnACPlug)
EVENT_ITEM(NVTEVT_AC_UnPlug, UIFlowWndMovie_OnACUnplug)
EVENT_ITEM(NVTEVT_CB_ADAS_SHOWALARM, UIFlowWndMovie_OnADASShowAlarm)      //#NT#2016/03/25#New ADAS#KCHong
//#NT#2016/06/23#Niven Cho -begin
//#NT#Enter calibration by cgi event or command event
EVENT_ITEM(NVTEVT_KEY_CALIBRATION, UIFlowWndMovie_OnKeyCalibration)
//#NT#2016/06/23#Niven Cho -end
//#NT#2016/07/20#Brain Yen -begin
//#NT#Add for DDD alarm
EVENT_ITEM(NVTEVT_CB_DDD_SHOWALARM, UIFlowWndMovie_OnDDDShowAlarm)
//#NT#2016/07/20#Brain Yen -end
EVENT_ITEM(NVTEVT_BACKGROUND_DONE, UIFlowWndMovie_OnBackgroundDone)
#if (WIFI_UI_DIRECT_MOBILE_LINKOK == ENABLE)
EVENT_ITEM(NVTEVT_WIFI_AUTHORIZED_OK, UIFlowWndMovie_OnWifiAuthorizeOK)
#endif
EVENT_ITEM(NVTEVT_ACC_OFF_TIMELAPSE, UIFlowWndMovie_OnEnterAccOffTimelapse)
EVENT_ITEM(NVTEVT_ACC_OFF_EXIT_TIMELAPSE, UIFlowWndMovie_OnExitAccOffTimelapse)

EVENT_END

// Movie mode key mask
#define MOVIE_KEY_PRESS_MASK        (FLGKEY_MENU|FLGKEY_ENTER|FLGKEY_UP|FLGKEY_DOWN)//(FLGKEY_SHUTTER2|FLGKEY_RIGHT|FLGKEY_LEFT|FLGKEY_CUSTOM1|FLGKEY_UP|FLGKEY_DOWN)
#define MOVIE_KEY_RELEASE_MASK      (FLGKEY_MENU|FLGKEY_ENTER|FLGKEY_UP|FLGKEY_DOWN)//(FLGKEY_SHUTTER2|FLGKEY_RIGHT|FLGKEY_LEFT|FLGKEY_CUSTOM1|FLGKEY_UP|FLGKEY_DOWN)

//-----------------------------------------------------------------------------------------
BOOL test = TRUE;
//static BOOL    g_uiRecordIngMotionDet = TRUE;
BOOL    g_uiRecordIngMotionDet = FALSE;//pqw

#if (_ADAS_FUNC_ == ENABLE)
UINT32 g_uiAdasAlertSecCnt = 0;
#endif  // #if (_ADAS_FUNC_ == ENABLE)
static UINT32  gUIMotionDetTimerID = NULL_TIMER;
static UINT32  g_uiDateTimerID = NULL_TIMER;
static UINT32  g_UIStopRecTimerID = NULL_TIMER;
static UINT32  g_uiMaskKeyPress      = MOVIE_KEY_PRESS_MASK;
static UINT32  g_uiMaskKeyRelease    = MOVIE_KEY_RELEASE_MASK;
//static UINT32 g_uiMaskKeyContinue   = MOVIE_KEY_CONTINUE_MASK;
static volatile BOOL g_bRedLEDOn = FALSE;
static volatile BOOL g_ACPlug = FALSE;
static volatile BOOL g_PreviewStable = FALSE;
static volatile BOOL g_PreviewStable_Record = FALSE; 
BOOL g_bSpeLockFun = FALSE;
_ALIGNED(4)  GPSDATA gpsdata = {0};
static UINT32 g_uiRecStopTimerCnt     = 0;
#if(CARD_ERROR_RESET == ENABLE)
BOOL  g_bRecStable = FALSE;
#endif

#if 0
static UINT32 Sys_GetDayMaxByDate(struct tm *pDateTime)
{
    UINT32 day_max;

    switch (pDateTime->tm_mon)
    {
    case 4:
    case 6:
    case 9:
    case 11:
        day_max = 30;
        break;
    case 2:
        day_max = ((pDateTime->tm_year % 4) || (pDateTime->tm_year == 2000)) ? 28 : 29;
        break;
    default:
        day_max = 31;
        break;
    }

    return day_max;
}

static void Sys_GetDateTimeBySecShift(struct tm *pOriTime, struct tm *pNewTime, UINT32 uiSecShift)
{
    UINT32  year, month, day, hour, min, sec;
    UINT32  day_max, day_add, hour_add, min_add, sec_add;

    // limitation: suppose timelapse time is not over 1 month
    sec_add  = (uiSecShift % 60);
    min_add  = (uiSecShift / 60) % 60;
    hour_add = (uiSecShift / 3600) % 24;
    day_add  = (uiSecShift / 86400);

    sec      = pOriTime->tm_sec  + sec_add;
    min      = pOriTime->tm_min  + min_add;
    hour     = pOriTime->tm_hour + hour_add;
    day      = pOriTime->tm_mday + day_add;
    month    = pOriTime->tm_mon;
    year     = pOriTime->tm_year;

    if (sec >= 60)
        min++;

    if (min >= 60)
        hour++;

    if (hour >= 24)
        day++;

    day_max = Sys_GetDayMaxByDate(pOriTime);

    pNewTime->tm_sec  = sec  % 60;
    pNewTime->tm_min  = min  % 60;
    pNewTime->tm_hour = hour % 24;

    if ((int)day == pOriTime->tm_mday)
    {
        pNewTime->tm_mday = day;
    }
    else if ((day % day_max) == 0)
    {
        pNewTime->tm_mday = day_max;
    }
    else
    {
        pNewTime->tm_mday = day  % day_max;
    }

    if (day > day_max)
        month++;

    if (month > 12)
        year++;

    if ((int)month == pOriTime->tm_mon)
    {
        pNewTime->tm_mon = month;
    }
    else if ((month % 12) == 0)
    {
        pNewTime->tm_mon = 12;
    }
    else
    {
        pNewTime->tm_mon  = month % 12;
    }

    pNewTime->tm_year = year;

    DBG_MSG("Ori: %04d/%02d/%02d %02d:%02d:%02d\r\n",
        pOriTime->tm_year, pOriTime->tm_mon, pOriTime->tm_mday, pOriTime->tm_hour, pOriTime->tm_min, pOriTime->tm_sec);

    DBG_MSG("Add: %d sec, %02d:%02d:%02d:%02d\r\n",
        uiSecShift, day_add, hour_add, min_add, sec_add);

    DBG_MSG("New: %04d/%02d/%02d %02d:%02d:%02d\r\n",
        pNewTime->tm_year, pNewTime->tm_mon, pNewTime->tm_mday, pNewTime->tm_hour, pNewTime->tm_min, pNewTime->tm_sec);
}

void Sys_AutoReboot(UINT32 uiSec)
{CHKPNT;
    struct tm currDateTime;
    struct tm alarmDateTime = {0};

    rtc_waitCSETDone(); //wait for last time write setting to RTC is completed. (EX: date, time, key)

    // get current date/time
    currDateTime = HwClock_GetTime(TIME_ID_CURRENT);
    DBG_MSG("Sys_AutoReboot, curr:  %04d/%02d/%02d %02d:%02d:%02d\r\n",
        currDateTime.tm_year, currDateTime.tm_mon, currDateTime.tm_mday, currDateTime.tm_hour, currDateTime.tm_min, currDateTime.tm_sec);

    // get alarm date/time
    Sys_GetDateTimeBySecShift(&currDateTime, &alarmDateTime, uiSec);
	DBG_MSG("Sys_AutoReboot, alarm: %04d/%02d/%02d %02d:%02d:%02d\r\n",
		alarmDateTime.tm_year, alarmDateTime.tm_mon, alarmDateTime.tm_mday, alarmDateTime.tm_hour, alarmDateTime.tm_min, alarmDateTime.tm_sec);

    // set alarm date/time and enable power alarm
	HwClock_SetTime(TIME_ID_HWRT, alarmDateTime, 0);
	HwPower_SetPowerKey(POWER_ID_HWRT, FALSE); // Disable->Enable to clear flags.
	HwPower_SetPowerKey(POWER_ID_HWRT, TRUE);
	alarmDateTime = HwClock_GetTime(TIME_ID_HWRT);
	DBG_MSG("Sys_AutoReboot, HWRT:  %04d/%02d/%02d %02d:%02d:%02d\r\n",
		alarmDateTime.tm_year, alarmDateTime.tm_mon, alarmDateTime.tm_mday, alarmDateTime.tm_hour, alarmDateTime.tm_min, alarmDateTime.tm_sec);
	rtc_waitCSETDone();

    // turn off power
    //System_PowerOff(SYS_POWEROFF_NORMAL);
	Ux_PostEvent(NVTEVT_SYSTEM_SHUTDOWN, 1, 0);
}
#endif

#if (USE_FILEDB==DISABLE)
static void UIFlowWndMovie_DeleteEmptyFolder(void)
{
	SDCFDIRINFO dirinfo;
	char   path[DCF_FULL_FILE_PATH_LEN];
	UINT32 uiMaxFolderID, uiPrevMaxFolderID;
	UINT32 uiStrlen;
	BOOL ret;

	uiMaxFolderID = DCF_GetDBInfo(DCF_INFO_MAX_DIR_ID);
// check if folder has file
	ret = DCF_GetDirInfo(uiMaxFolderID, &dirinfo);
	if (ret) {
		while (dirinfo.uiNumOfDcfObj == 0) {
			DCF_GetDirPath(uiMaxFolderID, path);
			uiStrlen = strlen(path);
			path[uiStrlen - 1] = '\0';
			if (FileSys_DeleteDir(path) != FST_STA_OK) {
				debug_msg("FileSys_DeleteDir failed\r\n");
			}

			DCF_Refresh();

			uiPrevMaxFolderID = uiMaxFolderID;
			// search another Max Empty folder ID
			uiMaxFolderID = DCF_GetDBInfo(DCF_INFO_MAX_DIR_ID);

			// break if getting max folder id is always same
			if (uiPrevMaxFolderID == uiMaxFolderID) {
				break;
			}
			// check if folder has file
			ret = DCF_GetDirInfo(uiMaxFolderID, &dirinfo);

			if (ret == FALSE) {
				break;
			}
		}
	}
}
#endif

BOOL g_lcdbacklightstus = TRUE;
static UINT32 count10sec = 10;
void UIFlowWndMovie_LcdBackLightCrl(BOOL crl_flag)
{CHKPNT;
	GxVideo_SetDeviceCtrl(DOUT1, DISPLAY_DEVCTRL_BACKLIGHT, crl_flag);
	g_lcdbacklightstus = crl_flag;
	count10sec =10;
}

BOOL UIFlowWndMovie_GetLcdBacklightStus(void)
{
	return g_lcdbacklightstus;
}
void UIFlowWndMovie_AutoBackLightOff(void)//10秒自动关屏
{
	count10sec --;
	if(count10sec <= 0)
	{
		count10sec = 10;
		if(UIFlowWndMovie_GetLcdBacklightStus())
			UIFlowWndMovie_LcdBackLightCrl(FALSE);
	}
}

void MovieChangeViewDualCam(void)
{

#if (defined(_NVT_ETHREARCAM_RX_))
	UINT16 id;
	UINT32 temp;
	for(id=0;id<ETH_REARCAM_CAPS_COUNT;id++)
	{
		if(EthCamNet_GetEthLinkStatus(id)==ETHCAM_LINK_DOWN)
			return;
	}
	
	DBGD(SysGetFlag(FL_DUAL_CAM));
	temp = SysGetFlag(FL_DUAL_CAM);
	temp++;
	if(temp > DUALCAM_BOTH2)
		temp = DUALCAM_FRONT;
	
	SysSetFlag(FL_DUAL_CAM_MENU, temp);
	SysSetFlag(FL_DUAL_CAM, temp);
	
	/*if(SysGetFlag(FL_DUAL_CAM) == DUALCAM_BEHIND)
	{
		SysSetFlag(FL_DUAL_CAM_MENU, DUALCAM_FRONT);
		SysSetFlag(FL_DUAL_CAM, DUALCAM_FRONT);
	}
	else
	{
		SysSetFlag(FL_DUAL_CAM_MENU, DUALCAM_BEHIND);
		SysSetFlag(FL_DUAL_CAM, DUALCAM_BEHIND);
	}*/
	
#endif
}

INT32 UIFlowWndMovie_OnExeRecord(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32 uiKeyAct;
	UINT32 uiState;
	BOOL   CheckStorageErr = FALSE;
	UINT32 uiEvent = 0;

	// flush key event first
	Ux_FlushEventByRange(NVTEVT_KEY_EVT_START, NVTEVT_KEY_EVT_END);

	// if HDMI is inserted, DRAM size is not enough for movie recording
	#if 0
	if (UI_GetData(FL_MOVIE_SIZE) == MOVIE_SIZE_FRONT_2880x2160P50 ||
		UI_GetData(FL_MOVIE_SIZE) == MOVIE_SIZE_FRONT_3840x2160P30 ||
		UI_GetData(FL_MOVIE_SIZE) == MOVIE_SIZE_FRONT_2880x2160P24) {
		if (KeyScan_GetPlugDev() == PLUG_HDMI) {
			return NVTEVT_CONSUME;
		}
	}
    #endif

	if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE) {
		if (System_GetState(SYS_STATE_CARD)  == CARD_REMOVED) {
			Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD, FLOWWRNMSG_TIMER_2SEC);
			return NVTEVT_CONSUME;
		}
	} else if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_NORMAL) {
		if (GxStrg_GetDeviceCtrl(0, CARD_READONLY)) { // card lock
			Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_LOCKED, FLOWWRNMSG_TIMER_2SEC);
			return NVTEVT_CONSUME;
		}

		if (!GxStrg_GetDeviceCtrl(0, CARD_INSERT)) { // card insert
			Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD, FLOWWRNMSG_TIMER_2SEC);
			return NVTEVT_CONSUME;
		}
	}

	if (paramNum >= 3) {
		uiState = paramArray[2];
	} else {
	    if(paramNum >= 2)
			uiEvent = paramArray[1];
		uiState = 0;
	}

	uiKeyAct = paramNum ? paramArray[0] : 0;

	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
		//#NT#2016/03/07#KCHong -begin
		//#NT#Low power timelapse function
#if (TIMELAPSE_LPR_FUNCTION == ENABLE)
		if ((MovieTLLPR_Process(TIMELAPSE_FROM_UI) & TL_FLOW_MASK) == TL_FLOW_LPR) {   // TimelapseLPR module will handle recording process
// For TimelapseLPR OSD display test
			UxCtrl_SetDirty(&UIFlowWndMovieCtrl, TRUE);
			break;
		}
#endif
//#NT#2016/03/07#KCHong -end
		switch (gMovData.State) {
		case MOV_ST_VIEW:
//#NT#2016/09/20#Bob Huang -begin
//#NT#Support HDMI Display with 3DNR Out
#if (_3DNROUT_FUNC == ENABLE)
			if (MovRec_GetStatus() == MOVREC_STATUS_OPENED_NOT_RECORD || gb3DNROut)
#else
			if (1)//MovRec_GetStatus() == MOVREC_STATUS_OPENED_NOT_RECORD)
#endif
//#NT#2016/09/20#Bob Huang -end
			{
				gMovData.State = MOV_ST_REC;
#if 1
				if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE) {
//#NT#2015/08/05#KS Hung -begin
//#NT#Even if the DCIM folder is not exist, FileSys_ScanDir stiil return FST_STA_OK.
//#NT#When the card is full and it sets cyclic record, it still can't record.
//#NT#MediaRec library will automatically delete the files of Car DV folder.
//#NT#if the files can't be deleted, it will have LOOPREC_FULL event in the callback.
					if (SysGetFlag(FL_MOVIE_CYCLIC_REC) == MOVIE_CYCLICREC_OFF) {
						CheckStorageErr = FlowMovie_IsStorageErr(TRUE);
					} else {
						CheckStorageErr = FlowMovie_IsStorageErr(FALSE);
					}
//#NT#2015/08/05#KS Hung -end

					if (CheckStorageErr == TRUE) {
						gMovData.State = MOV_ST_WARNING_MENU;
						gMovData.SysTimeCount = 0;
						Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_FULL, FLOWWRNMSG_TIMER_2SEC);
						return NVTEVT_CONSUME;
					}
				}
#endif
				if (GetBatteryLevel() == BATTERY_EXHAUSTED) {
					debug_err(("UIFlowWndMovie_OnExeRecord: Battery is too low!\r\n"));
					return NVTEVT_CONSUME;
				}

				if (FlowMovie_GetSelfTimerID() != NULL_TIMER) {
					FlowMovie_StopRecSelfTimer();
					return NVTEVT_CONSUME;
				}

				#if 0 //pqw
				if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON) {
					g_uiRecordIngMotionDet = TRUE;
				} else {
					g_uiRecordIngMotionDet = FALSE;
				}
				#endif
				
				if(!gbNoNeedVocieNotice)
				{CHKPNT;
				CHKPNT;
				CHKPNT;
					UISound_Play(DEMOSOUND_SOUND_RECORD_START_TONE);
				}else
				  	gbNoNeedVocieNotice = FALSE;

				FlowMovie_StartRec();
				
				if(uiEvent == UIFlowWndMovieRecordCrash)
				{
				   gDelayCrash = TRUE;
				}
				
				// start USB detect timer again
				if (g_ACPlug == TRUE) {
#if (USB_MODE == ENABLE)
					SxTimer_SetFuncActive(SX_TIMER_DET_USB_ID, TRUE);
#endif
				}
			}
			break;

		case MOV_ST_REC:
		case MOV_ST_REC|MOV_ST_ZOOM:
			UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl, FALSE);
#if (_ADAS_FUNC_ == ENABLE)
			g_uiAdasAlertSecCnt = 0;
#endif  // #if (_ADAS_FUNC_ == ENABLE)

			// Isiah, implement YUV merge mode of recording func.
			//if (FlowMovie_GetRecCurrTime() >= 1)
			{
				// Mask key during movie stop flow.
				Ux_FlushEventByRange(NVTEVT_KEY_EVT_START, NVTEVT_KEY_EVT_END);
				//Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);

#if (STOP_REC_BK == ENABLE)
				//bBK_StopRec =TRUE;
				//gMovData.State = MOV_ST_WARNING_MENU;
				if (uiState == UIFlowWndMovie_Restart_Rec){
				    //Ux_OpenWindow(&UIFlowWndWaitMomentCtrl, 1, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_RESTART_REC);
				}else{
				    //Ux_OpenWindow(&UIFlowWndWaitMomentCtrl, 1, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_STOPREC_WAIT);
				    if (g_UIStopRecTimerID == NULL_TIMER) {
				        g_UIStopRecTimerID = GxTimer_StartTimer(100, NVTEVT_01SEC_TIMER, CONTINUE);
				    }
				    //after 1 sec then go to WaitMoment Wnd
				    g_uiRecStopTimerCnt=10;
				}
				//#NT#2018/09/14#KCHong -begin
				//#NT# clear key mask when stop record flow is running
				Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
				Ux_FlushEventByRange(NVTEVT_KEY_SHUTTER2, NVTEVT_KEY_SHUTTER2);
				//#NT#2018/09/14#KCHong -end
				BKG_PostEvent(NVTEVT_BKW_STOPREC_PROCESS);
#else
				//bBK_StopRec =FALSE;
				FlowMovie_StopRec();
				// update ui window icon
				FlowMovie_UpdateIcons(TRUE);
#endif

				if (uiState == UIFlowWndMovie_Restart_Rec) {
					// Enable key if user pressed shutter2 key to stop recording.
					Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);

#if (STOP_REC_BK == ENABLE)
#if defined(_KEY_METHOD_4KEY_)
                    //for WaitMoment wnd use
					Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
#else
                    //for WaitMoment wnd use
					Ux_PostEvent(NVTEVT_KEY_SELECT, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
#endif
#else
#if defined(_KEY_METHOD_4KEY_)
					Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
#else
					Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
#endif
#endif
				} else {
				#if 0//pqw
					if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON) {
						if (g_uiRecordIngMotionDet == TRUE) {
							g_uiRecordIngMotionDet = FALSE;
//#NT#2016/11/01#Adam Su -begin
//#NT#fix mantis issue 0106933
							UI_SetData(FL_MOVIE_MOTION_DET, MOVIE_MOTIONDET_OFF);
//#NT#2016/11/01#Adam Su -end
							//#NT#2018/06/28#Brain Yen -begin
							//#NT#gira: CARDV_680-75
							FlowMovie_IconHideMotionDet(&UIFlowWndMovie_Status_MotionDetCtrl);
							//#NT#2018/06/28#Brain Yen -end
						}
					}
				#endif
				}
				
			}
			break;
		}
		break;
	}
#if defined(_KEY_METHOD_4KEY_)
	Ux_DefaultEvent(pCtrl, NVTEVT_KEY_SHUTTER2, paramNum, paramArray);
#else
	Ux_DefaultEvent(pCtrl, NVTEVT_KEY_SELECT, paramNum, paramArray);
#endif
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnExeZoomIn(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if(PHOTO_MODE==ENABLE)
	UINT32  uiKeyAct;

	uiKeyAct = paramNum ? paramArray[0] : 0;

	debug_ind(("[UIFlowWndMovie_OnExeZoomIn][%d]\n\r", uiKeyAct));

	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
	case NVTEVT_KEY_CONTINUE:
		if (0) { //((Photo_GetDZoomIdx()-10) > UI_DZOOM_IDX_MAX)
			Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
			gMovData.State &= ~MOV_ST_ZOOM;
			return NVTEVT_PASS;
		}
		switch (gMovData.State) {
		case MOV_ST_VIEW:
		case MOV_ST_REC:
		case MOV_ST_VIEW | MOV_ST_ZOOM:
		case MOV_ST_REC | MOV_ST_ZOOM:
			/* set Digital Zoom interface */
			UI_SetData(FL_ZoomIFIndex, ZOOM_IF_DIGITAL);

			gMovData.State |= MOV_ST_ZOOM;
			Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 2, UI_ZOOM_CTRL_IN, UI_GetData(FL_Dzoom));
			break;
		}
		break;

	case NVTEVT_KEY_RELEASE:
		switch (gMovData.State) {
		case MOV_ST_VIEW | MOV_ST_ZOOM:
		case MOV_ST_REC | MOV_ST_ZOOM:
			Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
			gMovData.State &= ~MOV_ST_ZOOM;
			break;
		}
		break;
	}
#endif
	return NVTEVT_PASS;
}

INT32 UIFlowWndMovie_OnExeZoomOut(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if(PHOTO_MODE==ENABLE)

	UINT32  uiKeyAct;

	uiKeyAct = paramNum ? paramArray[0] : 0;

	debug_ind(("[UIFlowWndMovie_OnExeZoomOut][%d]\n\r", uiKeyAct));

	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
	case NVTEVT_KEY_CONTINUE:
		switch (gMovData.State) {
		case MOV_ST_VIEW:
		case MOV_ST_REC:
		case MOV_ST_VIEW | MOV_ST_ZOOM:
		case MOV_ST_REC | MOV_ST_ZOOM:
			/* set Digital Zoom interface */
			UI_SetData(FL_ZoomIFIndex, ZOOM_IF_DIGITAL);

			gMovData.State |= MOV_ST_ZOOM;
			Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 2, UI_ZOOM_CTRL_OUT, UI_GetData(FL_Dzoom));
			break;
		}
		break;

	case NVTEVT_KEY_RELEASE:
		switch (gMovData.State) {
		case MOV_ST_VIEW | MOV_ST_ZOOM:
		case MOV_ST_REC | MOV_ST_ZOOM:
			Ux_SendEvent(&CustomPhotoObjCtrl, NVTEVT_EXE_ZOOM, 2, UI_ZOOM_CTRL_STOP, UI_GetData(FL_Dzoom));
			gMovData.State &= ~MOV_ST_ZOOM;
			break;
		}
		break;
	}
#endif
	return NVTEVT_PASS;
}

void UIFlowWndMovie_Initparam(void)
{
#if(PHOTO_MODE==ENABLE)
	// The same effect as Photo mode
	Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_WB,                  1,  SysGetFlag(FL_WB));

	// The other settings
	Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_COLOR,               1,  MOVIE_COLOR_NORMAL);
#endif
	/* Video resolution setting must be set after other IQ settings */
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIESIZE,           1,  SysGetFlag(FL_MOVIE_SIZE));

	/* Cyclic recording/record with mute or sound/DateImptint/Motion Detect */
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_CYCLIC_REC,          1,  SysGetFlag(FL_MOVIE_CYCLIC_REC));
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOTION_DET,          1,  SysGetFlag(FL_MOVIE_MOTION_DET));
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_DATE_IMPRINT,  1,  SysGetFlag(FL_MOVIE_DATEIMPRINT));
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_AUDIO,         1,  SysGetFlag(FL_MOVIE_AUDIO));
#if(PHOTO_MODE==ENABLE)
	Ux_SendEvent(&CustomPhotoObjCtrl,   NVTEVT_EXE_EV,                  1,  SysGetFlag(FL_EV));
#endif
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_MCTF,          1,  SysGetFlag(FL_MovieMCTFIndex));
	//Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_WDR,           1,  SysGetFlag(FL_MOVIE_WDR));
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_HDR,           1,  SysGetFlag(FL_MOVIE_HDR));
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_DEFOG,           1,  SysGetFlag(FL_MOVIE_DEFOG));
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_GSENSOR,             1,  SysGetFlag(FL_GSENSOR));
#if (ETHCAM_TX_DISPLAY_FLIP == DISABLE)
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_SENSOR_ROTATE, 1,  SysGetFlag(FL_MOVIE_SENSOR_ROTATE));
#endif
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_IR_CUT,        1,  SysGetFlag(FL_MOVIE_IR_CUT));
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_PROTECT_AUTO,  1,  SysGetFlag(FL_MOVIE_URGENT_PROTECT_AUTO));
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_PROTECT_MANUAL, 1,  SysGetFlag(FL_MOVIE_URGENT_PROTECT_MANUAL));
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_LDWS,          1,  SysGetFlag(FL_MOVIE_LDWS));
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_FCW,           1,  SysGetFlag(FL_MOVIE_FCW));
	Ux_SendEvent(&UISetupObjCtrl,       NVTEVT_EXE_FREQ,                1,  SysGetFlag(FL_FREQUENCY));
#if (MOVIE_RSC == ENABLE)
	Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_RSC, 1, MOVIE_RSC_ON);
#endif
#if MOVIE_DIS
	Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIEDIS,            1,  MOVIE_DIS_ON);
#endif
#if SHDR_FUNC
	//Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_SHDR,                1,  MOVIE_HDR_ON);
#endif
	Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_CODEC, 1, SysGetFlag(FL_MOVIE_CODEC));
}

static BOOL g_bDelayUpdateIcon = FALSE;

INT32 UIFlowWndMovie_OnOpen(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	g_uiRecStopTimerCnt=0;
	//#NT#2016/03/07#KCHong -begin
	//#NT#Low power timelapse function, do not show OSD if boot from alarm
#if (TIMELAPSE_LPR_FUNCTION == ENABLE)
	if (MovieTLLPR_CheckHWRTStatus() == TL_HWRT_BOOT_ALARM) {
		UxCtrl_SetAllChildShow(pCtrl, FALSE);
		return NVTEVT_CONSUME;
	}
#endif
//#NT#2016/03/07#KCHong -end

	//#NT#2015/07/17#KS Hung -begin
	//#NT#For ADAS
	UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl, FALSE);
	UxCtrl_SetShow(&UIFlowWndMovie_Panel_Normal_DisplayCtrl, TRUE);
	//#NT#2015/07/17#KS Hung -end

	Ux_FlushEventByRange(NVTEVT_KEY_EVT_START, NVTEVT_KEY_EVT_END);
	/* Init window key mask variables & set key and key released mask */
	g_uiMaskKeyPress = MOVIE_KEY_PRESS_MASK;
	g_uiMaskKeyRelease = MOVIE_KEY_RELEASE_MASK;
	Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
	//Input_SetKeyMask(KEY_RELEASE, g_uiMaskKeyPress);
	CHKPNT;
	Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);//zjf 20201012
	if(curmode != MODE_MOVIE)
		Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);
	else
		//Input_SetKeyMask(KEY_CONTINUE, g_uiMaskKeyPress);
		Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);//zjf 20201012
		
#if (GSENSOR_FUNCTION == ENABLE)
	if (UI_GetData(FL_MOVIE_SIZE) == MOVIE_SIZE_FRONT_640x480P240
		&& UI_GetData(FL_GSENSOR) != GSENSOR_OFF) {
		UI_SetData(FL_GSENSOR, GSENSOR_OFF);
		DBG_ERR("G-Sensor is not support on fps=240, because i2c is too busy.\r\n");
	}
//MUST open before UIFlowWndMovie_Initparam, because Initparam call GSensor_SetSensitivity.
	GSensor_open();
#endif

	if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE) {
#if USE_FILEDB
		if (UI_GetData(FL_IsUseFileDB)) {
			Ux_SendEvent(&UISetupObjCtrl, NVTEVT_FILEID_RESET, 0);
		}
#endif
	}

	UIFlowWndMovie_Initparam();
	g_wifi_info_show = TRUE;

	if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE) {
#if(ONVIF_PROFILE_S!=ENABLE) //No File System
		if (UIStorageCheck(STORAGE_CHECK_ERROR, NULL) == TRUE) {
			Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD, FLOWWRNMSG_TIMER_KEEP);
		}
#endif
	}

	// update g_uiRecordIngMotionDet flag
	if (gUIMotionDetTimerID == NULL_TIMER) {
		gUIMotionDetTimerID = GxTimer_StartTimer(TIMER_HALF_SEC, NVTEVT_05SEC_TIMER, CONTINUE);
	}

	if (g_uiDateTimerID == NULL_TIMER) {
		g_uiDateTimerID = GxTimer_StartTimer(TIMER_ONE_SEC, NVTEVT_1SEC_TIMER, CONTINUE);
	}

	// Enable Motion Detect function in starting up movie mode
	#if 0//pqw
	if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON) {
		g_uiRecordIngMotionDet = TRUE;
	} else {
		g_uiRecordIngMotionDet = FALSE;
	}
	#endif

	// delete empty folder
#if (USE_FILEDB==DISABLE)
	UIFlowWndMovie_DeleteEmptyFolder();
#endif

//factory test
	 if(bDemoStart)
       FlowMovie_DeleteFile(DELETE_ALL);
//

	Ux_DefaultEvent(pCtrl, NVTEVT_OPEN_WINDOW, paramNum, paramArray);

#if ((POWERON_FAST_WIFI != ENABLE) && (POWERON_FAST_RECORD == ENABLE))
	if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_NORMAL) {
// fast record
		UINT32 paramArray[1] = {NVTEVT_KEY_PRESS};
		UIFlowWndMovie_OnExeRecord(pCtrl, 1, paramArray);
	}

	if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE) {
		FlowMovie_UpdateIcons(TRUE);
	} else {
		FlowMovie_UpdateIcons(FALSE);
		UI_SetDisplayFlip(FALSE);
		g_bDelayUpdateIcon = TRUE;
	}
#else
	FlowMovie_UpdateIcons(TRUE);
#endif

#if(IS_ALPHA_TYPEFMT(DISPLAY_OSD_FMT))
	/* open VDO2 background */
	UI_Show(UI_SHOW_BACKGND, TRUE);
#endif
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	CHKPNT;
	UIFlowWndMovie_ALG_Clear_OSD();
	switch (gMovData.State) {
	case MOV_ST_REC:
	case MOV_ST_REC|MOV_ST_ZOOM:
		if (FlowMovie_GetRecCurrTime() <= 1) {
			Delay_DelayMs(1000);
		}
		FlowMovie_StopRec();
		Ux_SendEvent(&UIFlowWndMovieCtrl, NVTEVT_CB_MOVIE_FINISH, 0);
		break;
	}

	g_bRedLEDOn = FALSE;
	//KeyScan_TurnOffLED(KEYSCAN_LED_RED);

	if (gUIMotionDetTimerID != NULL_TIMER) {
		GxTimer_StopTimer(&gUIMotionDetTimerID);
	}

	if (g_uiDateTimerID != NULL_TIMER) {
		GxTimer_StopTimer(&g_uiDateTimerID);
	}

	if (g_UIStopRecTimerID != NULL_TIMER) {
		GxTimer_StopTimer(&g_UIStopRecTimerID);
	}

#if (GSENSOR_FUNCTION == ENABLE)
	GSensor_close();
#endif

	Ux_DefaultEvent(pCtrl, NVTEVT_CLOSE_WINDOW, paramNum, paramArray);
	return NVTEVT_CONSUME;
}

static void UIFlowWndMovie_OnALGEnd(void)
{
	UxCtrl_SetShow(&UIFlowWndMovie_ALG_DrawCtrl, TRUE);
	/* Redraw all window OSD */
	UxCtrl_SetDirty(&UIFlowWndMovieCtrl, TRUE);
}
INT32 UIFlowWndMovie_OnUpdateInfo(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	if (paramNum == 0) {
		return NVTEVT_CONSUME;
	}
	switch (paramArray[0]) {
	case UIAPPPHOTO_CB_ALGEND:
		UIFlowWndMovie_OnALGEnd();
		break;
	default:
		DBG_ERR("Unknown CB %d\r\n", paramArray[0]);
	}

	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnKeyNext(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	// next key
	UINT32  uiKeyAct;
	UINT32  uiSoundMask;

	uiKeyAct = paramArray[0];

	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
		switch (gMovData.State) {
		case MOV_ST_VIEW:
		case MOV_ST_VIEW|MOV_ST_ZOOM:
			// stope timer when entering menu
			if (gUIMotionDetTimerID != NULL_TIMER) {
				GxTimer_StopTimer(&gUIMotionDetTimerID);
			}

			if (g_uiDateTimerID != NULL_TIMER) {
				GxTimer_StopTimer(&g_uiDateTimerID);
			}

			if (g_UIStopRecTimerID != NULL_TIMER) {
				GxTimer_StopTimer(&g_UIStopRecTimerID);
			}

			// Enable shutter2 sound (Select key as OK key in menu)
			uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
			uiSoundMask |= FLGKEY_ENTER;
			Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);
			Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);

			// Open common mix (Item + Option) menu
			Ux_OpenWindow((VControl *)(&MenuCommonItemCtrl), 0);
			gMovData.State = MOV_ST_MENU;
			break;
		case MOV_ST_REC:
		case MOV_ST_REC|MOV_ST_ZOOM:
			if (SysGetFlag(FL_MOVIE_URGENT_PROTECT_MANUAL) == MOVIE_URGENT_PROTECT_MANUAL_ON) {
#if (MOVIE_MULTI_RECORD_FUNC)
				if (GetMovieRecType_2p(UI_GetData(FL_MOVIE_SIZE)) == MOVIE_REC_TYPE_FRONT) {
#if(defined(_NVT_ETHREARCAM_RX_))
					ImageApp_MovieMulti_SetCrash(_CFG_REC_ID_1, TRUE);
					UINT32 i;
					for (i = 0; i < ETH_REARCAM_CAPS_COUNT; i++) {
						if(socketCliEthData1_IsRecv(ETHCAM_PATH_ID_1 +i)){
							ImageApp_MovieMulti_SetCrash(_CFG_ETHCAM_ID_1+i, TRUE);
						}
					}
#else
					ImageApp_MovieMulti_TrigEMR(_CFG_REC_ID_1);
#endif
				} else {
					UINT32 i, mask, movie_rec_mask;

 					movie_rec_mask = Movie_GetMovieRecMask();
					mask = 1;
					for (i = 0; i < SENSOR_CAPS_COUNT; i++) {
						if (movie_rec_mask & mask) {
							ImageApp_MovieMulti_SetCrash(_CFG_REC_ID_1 + i, TRUE);
						}
						mask <<= 1;
					}
				}
#else
				ImageApp_Movie_SetParam(_CFG_REC_ID_1, MOVIE_PARAM_FILE_TRIGEMR, 1);
#endif
				Ux_DefaultEvent(pCtrl, NVTEVT_KEY_NEXT, paramNum, paramArray);
				return NVTEVT_CONSUME;
			}
			break;
		}
		break;
	}

	Ux_DefaultEvent(pCtrl, NVTEVT_KEY_NEXT, paramNum, paramArray);
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnKeySelect(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32  uiKeyAct;

	// Similar to Shutter2 key
	uiKeyAct = paramArray[0];
	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS: {
			/*
			if (gMovData.State==MOV_ST_VIEW)
			{
			    gMovData.State=MOV_ST_REC;

			}
			else if (gMovData.State==MOV_ST_REC)
			{
			    gMovData.State=MOV_ST_VIEW;
			    // update ui window icon
			    FlowMovie_UpdateIcons(TRUE);
			}
			*/
			UIFlowWndMovie_OnExeRecord(pCtrl, paramNum, paramArray);
		}
		break;
	}
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyMenu(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
CHKPNT;
DBGD(curmode);
DBGD(gMovData.State);
	Input_GetKeyMask(KEY_RELEASE);

	UINT32  uiKeyAct;
	UINT32  uiSoundMask;
	uiKeyAct = paramArray[0];
	#if 1
	if(gMovData.State == MOV_ST_REC)
	{
		if(!g_bRecordLock)
			return UIFlowWndMovie_OnKeyCustom1(pCtrl,paramNum,paramArray);
	}
	#endif
	
	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
		Input_SetKeyMask(KEY_RELEASE,FLGKEY_MENU);
		Input_SetKeyMask(KEY_CONTINUE,FLGKEY_MENU);
		CHKPNT;
		break;
		
	case NVTEVT_KEY_RELEASE:
		CHKPNT;
		switch (gMovData.State) {
		case MOV_ST_VIEW:
		case MOV_ST_VIEW|MOV_ST_ZOOM:
			if(curmode != MODE_MOVIE )
			{	CHKPNT;
				curmode = MODE_MOVIE;	
				Input_SetKeyMask(KEY_CONTINUE, FLGKEY_MENU);
				return NVTEVT_CONSUME;
			}
			// stope timer when entering menu
			if (gUIMotionDetTimerID != NULL_TIMER) {
				GxTimer_StopTimer(&gUIMotionDetTimerID);
			}

			if (g_uiDateTimerID != NULL_TIMER) {
				GxTimer_StopTimer(&g_uiDateTimerID);
			}

			if (g_UIStopRecTimerID != NULL_TIMER) {
				GxTimer_StopTimer(&g_UIStopRecTimerID);
			}
			// enable shutter2 sound (shutter2 as OK key in menu)
			uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
			uiSoundMask |= FLGKEY_ENTER;
			Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);

			Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
			Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);
			// Open common mix (Item + Option) menu
			Ux_OpenWindow((VControl *)(&MenuCommonItemCtrl), 0);
			gMovData.State = MOV_ST_MENU;
			curmode = MODE_CUSTOM;
			break;
		}
		break;

		case NVTEVT_KEY_CONTINUE:
			switch (gMovData.State) {
			case MOV_ST_VIEW:
			case MOV_ST_VIEW|MOV_ST_ZOOM:
				if(FlowMovie_IsStorageErr(FALSE))
				{	CHKPNT;
					Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);
					curmode = MODE_CUSTOM;
					return NVTEVT_CONSUME;	
				}
				// mask key while changing primary mode
				Ux_FlushEventByRange(NVTEVT_KEY_EVT_START, NVTEVT_KEY_EVT_END);
				Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
				Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
				Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);
				// changing primary mode
				Ux_SendEvent(&UISetupObjCtrl, NVTEVT_EXE_CHANGEDSCMODE, 1, DSCMODE_CHGTO_NEXT);
				break;
			}
			break;
			
	}
	//Ux_DefaultEvent(pCtrl, NVTEVT_KEY_MENU, paramNum, paramArray);
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnKeyEnter(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{CHKPNT;
    UINT32  uiKeyAct;

    uiKeyAct = paramArray[0];
	DBGD(gMovData.State);
    if(gMovData.State == MOV_ST_REC)
    {CHKPNT;
		if (FlowMovie_GetRecCurrTime() <= 1 && (SysGetFlag(FL_MOVIE_TIMELAPSE_REC) == MOVIE_TIMELAPSEREC_OFF))
		{
			CHKPNT;
			return NVTEVT_CONSUME;
		}
    }
	
    switch (uiKeyAct) {
        case NVTEVT_KEY_PRESS:
            Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
            break;
    }
    Ux_DefaultEvent(pCtrl, NVTEVT_KEY_ENTER, paramNum, paramArray);
    return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyDown(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{CHKPNT;
	//return UIFlowWndMovie_OnExeZoomOut(pCtrl, paramNum, paramArray);//test

	//if(bEnterTimelapse)//缩时录影时,按键只做唤醒LCD屏
	{
		if(UIFlowWndMovie_GetLcdBacklightStus() == FALSE)
			UIFlowWndMovie_LcdBackLightCrl(TRUE);
		//return NVTEVT_CONSUME;
	}
	
 	UINT32 uiEvtKeyAct = 0;

    if(paramNum > 0)
        uiEvtKeyAct = paramArray[0];

    switch(uiEvtKeyAct)
    {
        case NVTEVT_KEY_PRESS:
#if 1//(_VERSON_TYPE_ == _VERSON_RST_NORMAL_) //瑞世钛用作录音开关键
			if (SysGetFlag(FL_MOVIE_AUDIO) == MOVIE_AUDIO_ON)
				SysSetFlag(FL_MOVIE_AUDIO,MOVIE_AUDIO_OFF);
			else
				SysSetFlag(FL_MOVIE_AUDIO,MOVIE_AUDIO_ON);

			Ux_SendEvent(&CustomMovieObjCtrl,   NVTEVT_EXE_MOVIE_AUDIO, 1,  SysGetFlag(FL_MOVIE_AUDIO));
			FlowMovie_UpdateIcons(TRUE);
#else//其他客户用作抓拍键
			if (System_GetState(SYS_STATE_CURRMODE) != PRIMARY_MODE_MOVIE) {
				return NVTEVT_CONSUME;
			}
			if (ImageApp_MovieMulti_IsStreamRunning(_CFG_REC_ID_1) ||
				ImageApp_MovieMulti_IsStreamRunning(_CFG_REC_ID_2) ) {
				if(FlowMovie_GetCurrRecTotalTime() > 3)
				{
		            UISound_Play(DEMOSOUND_SOUND_SHUTTER_TONE);
		            Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 0);
				}
			} else {
			}
#endif

             break;
        case NVTEVT_KEY_RELEASE:
        default:
            break;

    }
	return NVTEVT_CONSUME;
}

#if 0
INT32 UIFlowWndMovie_OnKeyLeft(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32  uiKeyAct;
	UINT32  uiEV;

	uiKeyAct = paramNum ? paramArray[0] : 0;

	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
		switch (gMovData.State) {
		case MOV_ST_VIEW:
		case MOV_ST_VIEW|MOV_ST_ZOOM:
			uiEV = SysGetFlag(FL_EV);
			if (uiEV == EV_N20) {
				SysSetFlag(FL_EV, EV_P20);
			} else {
				SysSetFlag(FL_EV, ++uiEV);
			}
			Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_EV, 1, SysGetFlag(FL_EV));
			FlowMovie_IconDrawEV(&UIFlowWndMovie_StatusICN_EVCtrl);
			break;
		case MOV_ST_REC:
			if (SysGetFlag(FL_MOVIE_CYCLIC_REC) != MOVIE_CYCLICREC_OFF && FlowMovie_GetRecCurrTime() >= 1) {
#if (0)//(PRJ == APC3)
				g_bSpeLockFun = TRUE;
				FlowMovie_StopRec();
				Ux_SendEvent(pCtrl, NVTEVT_CB_MOVIE_FINISH, 1, UIFlowWndMovie_Restart_Rec);
#endif
			}
			break;
		}
		break;
	}

	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnKeyRight(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32  uiKeyAct;

	uiKeyAct = paramArray[0];

	switch (uiKeyAct) {
	case NVTEVT_KEY_PRESS:
		switch (gMovData.State) {
		case MOV_ST_REC:
		case MOV_ST_REC|MOV_ST_ZOOM: {
				FlowMovie_DrawPIM(TRUE);
				Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 0);
			}
			break;
		}
		break;
	// Enter menu
	default:
		Ux_PostEvent(NVTEVT_KEY_MENU, 1, NVTEVT_KEY_PRESS);
		break;
	}

	return NVTEVT_CONSUME;
}
#endif
INT32 UIFlowWndMovie_OnChildClose(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{CHKPNT;
	UINT32  uiSoundMask;

	switch (gMovData.State) {
	case MOV_ST_WARNING_MENU:
		if (paramNum > 0) {
			if (paramArray[0] == NVTRET_ENTER_MENU) {
				/* Create Menu window */
				gMovData.State = MOV_ST_MENU;
				Ux_OpenWindow(&MenuCommonItemCtrl, 0);
				return NVTEVT_CONSUME;
			}
		}
		gMovData.State = MOV_ST_VIEW;
		CHKPNT;
		break;

	case MOV_ST_MENU:
		CHKPNT;
		// disable shutter2 sound
		uiSoundMask = Input_GetKeySoundMask(KEY_PRESS);
		uiSoundMask &= ~FLGKEY_ENTER;
		Input_SetKeySoundMask(KEY_PRESS, uiSoundMask);

		g_uiMaskKeyPress = MOVIE_KEY_PRESS_MASK;
		g_uiMaskKeyRelease = MOVIE_KEY_RELEASE_MASK;
		Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
		Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
		FlowMovie_UpdateIcons(TRUE);

		// start timer again when exiting menu
		if (gUIMotionDetTimerID == NULL_TIMER) {
			gUIMotionDetTimerID = GxTimer_StartTimer(TIMER_HALF_SEC, NVTEVT_05SEC_TIMER, CONTINUE);
		}

		if (g_uiDateTimerID == NULL_TIMER) {
			g_uiDateTimerID = GxTimer_StartTimer(TIMER_ONE_SEC, NVTEVT_1SEC_TIMER, CONTINUE);
		}

		// Enable Motion Detect function in starting up movie mode
		#if 0//pqw
		if (SysGetFlag(FL_MOVIE_MOTION_DET) == MOVIE_MOTIONDET_ON) {
			g_uiRecordIngMotionDet = TRUE;
		} else {
			g_uiRecordIngMotionDet = FALSE;
		}
		#endif
		curmode = MODE_MOVIE;
		gMovData.State = MOV_ST_VIEW;
		break;
	case MOV_ST_VIEW:
		CHKPNT;
		if (paramNum > 0) {

			if ((paramNum == 2) && (paramArray[0] == NVTRET_WAITMOMENT)) {
				if (paramArray[1] == NVTRET_RESTART_REC) {
#if defined(_KEY_METHOD_4KEY_)
					Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
#else
					Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
#endif
            	} else {
					FlowMovie_UpdateIcons(TRUE);
				}
			}
		}
		break;
	}

	//#NT#2018/08/10#KCHong -begin
	//#NT#Fixed Jira NA51000-1230
	if (gMovData.State == MOV_ST_VIEW || gMovData.State == MOV_ST_REC) {
		FlowMovie_UpdateIcons(TRUE);
		if (ImageApp_MovieMulti_IsStreamRunning(_CFG_REC_ID_1) ||
			ImageApp_MovieMulti_IsStreamRunning(_CFG_REC_ID_2)) {
			gMovData.State = MOV_ST_REC;
		} else {
			gMovData.State = MOV_ST_VIEW;
		}
	}
	//#NT#2018/08/10#KCHong -end

#if(IS_ALPHA_TYPEFMT(DISPLAY_OSD_FMT))
	/* open VDO2 background */
	UI_Show(UI_SHOW_BACKGND, TRUE);
#endif
	Ux_DefaultEvent(pCtrl, NVTEVT_CHILD_CLOSE, paramNum, paramArray);
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyShutter2(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return UIFlowWndMovie_OnExeRecord(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndMovie_OnKeyZoomin(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return UIFlowWndMovie_OnExeZoomIn(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndMovie_OnKeyZoomout(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return UIFlowWndMovie_OnExeZoomOut(pCtrl, paramNum, paramArray);
}
INT32 UIFlowWndMovie_OnKeyUp(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{CHKPNT;
	//return UIFlowWndMovie_OnExeZoomOut(pCtrl, paramNum, paramArray);//test
	#if 0
	if (System_GetState(SYS_STATE_CURRMODE) != PRIMARY_MODE_MOVIE) {
		return NVTEVT_CONSUME;
	}

	if (ImageApp_MovieMulti_IsStreamRunning(_CFG_REC_ID_1) ||
		ImageApp_MovieMulti_IsStreamRunning(_CFG_REC_ID_2) ) {		
		if(FlowMovie_GetCurrRecTotalTime() > 3)
		{
            //UIVoice_Play(1, VOICE_CAP_DONE);		
            UISound_Play(DEMOSOUND_SOUND_SHUTTER_TONE);
            Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 0);
		}
	} else {
	}
	#endif

	UINT32  uiKeyAct;
	//UINT32  uiSoundMask;
	
	static  BOOL keyuplock = FALSE;

	uiKeyAct = paramArray[0];

	switch (uiKeyAct) {
		case NVTEVT_KEY_CONTINUE:
			CHKPNT;
			if(!keyuplock)
			{
				keyuplock = TRUE;
				if (UI_GetData(FL_WIFI_LINK) != WIFI_LINK_OK) 
				{
					UISound_Play(DEMOSOUND_SOUND_WIFI_ON_TONE);
					BKG_PostEvent(NVTEVT_BKW_WIFI_ON);
					//SysSetFlag(FL_AUTO_WIFI,AUTO_WIFI_ON);
					UI_SetData(FL_WIFI,WIFI_ON);
				}
				else
				{
					UISound_Play(DEMOSOUND_SOUND_WIFI_OFF_TONE);
					Ux_SendEvent(0,NVTEVT_EXE_WIFI_STOP, 0);
					//SysSetFlag(FL_AUTO_WIFI,AUTO_WIFI_OFF);
					UI_SetData(FL_WIFI,WIFI_OFF);
				}
			}
			break;
			
		case NVTEVT_KEY_PRESS:
			MovieChangeViewDualCam();
			break;
			
		case NVTEVT_KEY_RELEASE:
			keyuplock = FALSE;
			break;
			
		default:
			break;
	}
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnKeyPlayBack(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{

	// Don't stop movie recording
	switch (gMovData.State) {
	case MOV_ST_VIEW:
	case MOV_ST_VIEW|MOV_ST_ZOOM:
		// mask key while changing primary mode
		Ux_FlushEventByRange(NVTEVT_KEY_EVT_START, NVTEVT_KEY_EVT_END);

		Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
		Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
		Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);
		// changing primary mode
		Ux_SendEvent(&UISetupObjCtrl, NVTEVT_FORCETO_PLAYBACK_MODE, 0);
		break;
	}

	return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnBattery(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	static volatile BOOL bBatteryOn = FALSE;

	UxState_SetData(&UIFlowWndMovie_Status_batteryCtrl, STATE_CURITEM, GetBatteryLevel());
	if (KeyScan_IsACIn()) {
		bBatteryOn = !bBatteryOn;
		UxCtrl_SetShow(&UIFlowWndMovie_Status_batteryCtrl, bBatteryOn);
	} else {
		UxCtrl_SetShow(&UIFlowWndMovie_Status_batteryCtrl, TRUE);
	}

	return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnBatteryLow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_BATTERY_LOW, FLOWWRNMSG_TIMER_2SEC);
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyMode(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{CHKPNT;
	if(bEnterTimelapse)//缩时录影时,按键只做唤醒LCD屏
	{
		if(UIFlowWndMovie_GetLcdBacklightStus() == FALSE)
			UIFlowWndMovie_LcdBackLightCrl(TRUE);
		return NVTEVT_CONSUME;
	}
	// Don't stop movie recording
	switch (gMovData.State) {
	case MOV_ST_VIEW:
	case MOV_ST_VIEW|MOV_ST_ZOOM:
		// mask key while changing primary mode
		Ux_FlushEventByRange(NVTEVT_KEY_EVT_START, NVTEVT_KEY_EVT_END);
		Input_SetKeyMask(KEY_PRESS, FLGKEY_KEY_MASK_NULL);
		Input_SetKeyMask(KEY_RELEASE, FLGKEY_KEY_MASK_NULL);
		Input_SetKeyMask(KEY_CONTINUE, FLGKEY_KEY_MASK_NULL);
		// changing primary mode
		Ux_SendEvent(&UISetupObjCtrl, NVTEVT_EXE_CHANGEDSCMODE, 1, DSCMODE_CHGTO_NEXT);
		break;

	}
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnKeyCustom1(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{CHKPNT;
	if(g_bRecordLock)
		return NVTEVT_CONSUME;
	
	//if (SysGetFlag(FL_GSENSOR) != GSENSOR_OFF)
	{
	   	if ((gMovData.State == MOV_ST_REC) || (gMovData.State == MOV_ST_REC_WAIT))
		{
			if (SysGetFlag(FL_MOVIE_URGENT_PROTECT_AUTO) == MOVIE_URGENT_PROTECT_AUTO_ON) {
				if (GetMovieRecType_2p(UI_GetData(FL_MOVIE_SIZE)) == MOVIE_REC_TYPE_FRONT) {
#if(defined(_NVT_ETHREARCAM_RX_))
CHKPNT;
					ImageApp_MovieMulti_SetCrash(_CFG_REC_ID_1, TRUE);
					UINT32 i;
					for (i = 0; i < ETH_REARCAM_CAPS_COUNT; i++) {
						if(socketCliEthData1_IsRecv(ETHCAM_PATH_ID_1 +i)){
							ImageApp_MovieMulti_SetCrash(_CFG_ETHCAM_ID_1+i, TRUE);
						}
					}
					UISound_Play(DEMOSOUND_SOUND_RECORD_LOCK_TONE);
	                FlowMovie_DrawLock(TRUE);
					g_bRecordLock = TRUE;
#else
					ImageApp_MovieMulti_TrigEMR(_CFG_REC_ID_1);
#endif
				} else {
					UINT32 i, mask, movie_rec_mask;
CHKPNT;
 					movie_rec_mask = Movie_GetMovieRecMask();
					mask = 1;
					for (i = 0; i < SENSOR_CAPS_COUNT; i++) {
						if (movie_rec_mask & mask) {
							ImageApp_MovieMulti_SetCrash(_CFG_REC_ID_1 + i, TRUE);
						}
						mask <<= 1;
					}
					UISound_Play(DEMOSOUND_SOUND_RECORD_LOCK_TONE);
	                FlowMovie_DrawLock(TRUE);
					g_bRecordLock = TRUE;
				}
			}
		}
		else
		{
	        if(!FlowMovie_IsStorageErr(FALSE))
	        {     CHKPNT;
				//UISound_Play(DEMOSOUND_SOUND_RECORD_LOCK_TONE);
				g_bRecordLock = TRUE;
				Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 2, NVTEVT_KEY_PRESS,UIFlowWndMovieRecordCrash);
	        }
		}
		
	}

	return NVTEVT_CONSUME;

	
}

//智能语音录像处理
INT32 UIFlowWndMovie_OnKeyLock(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
   	if ((gMovData.State == MOV_ST_REC) || (gMovData.State == MOV_ST_REC_WAIT))
	{
		if (SysGetFlag(FL_MOVIE_URGENT_PROTECT_AUTO) == MOVIE_URGENT_PROTECT_AUTO_ON) 
		{
			if (GetMovieRecType_2p(UI_GetData(FL_MOVIE_SIZE)) == MOVIE_REC_TYPE_FRONT) 
			{
			
                #if (1)//_BOARD_DRAM_SIZE_ == 0x04000000)
				UISound_Play(DEMOSOUND_SOUND_RECORD_LOCK_TONE);
                FlowMovie_DrawLock(TRUE);
                ImageApp_MovieMulti_SetCrash(_CFG_REC_ID_1, TRUE);
				#else
				UISound_Play(DEMOSOUND_SOUND_RECORD_LOCK_TONE);
				FlowMovie_DrawLock(TRUE);
				ImageApp_MovieMulti_TrigEMR(_CFG_REC_ID_1);
				#endif
			} 
			else {
				UINT32 i, mask, movie_rec_mask;
                UISound_Play(DEMOSOUND_SOUND_RECORD_LOCK_TONE);
				movie_rec_mask = Movie_GetMovieRecMask();
				mask = 1;
				for (i = 0; i < SENSOR_CAPS_COUNT; i++) {
					if (movie_rec_mask & mask) {
						ImageApp_MovieMulti_SetCrash(_CFG_REC_ID_1 + i, TRUE);
					}
					mask <<= 1;
				}
			}
		}
		else
		{
		   UISound_Play(DEMOSOUND_SOUND_RECORD_LOCK_TONE);
           FlowMovie_DrawLock(TRUE);
		   ImageApp_MovieMulti_SetCrash(_CFG_REC_ID_1, TRUE);
		}
	}
	else
	{
        if(!FlowMovie_IsStorageErr(FALSE))
        {            
			UISound_Play(DEMOSOUND_SOUND_RECORD_LOCK_TONE);
			Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 2, NVTEVT_KEY_PRESS,UIFlowWndMovieRecordEMR);
        }
	}
	

return NVTEVT_CONSUME;
	
}

//智能语音抓拍处理
INT32 UIFlowWndMovie_OnKeyCapture(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{CHKPNT;
	if (System_GetState(SYS_STATE_CURRMODE) != PRIMARY_MODE_MOVIE) {
		return NVTEVT_CONSUME;
	}

	if (ImageApp_MovieMulti_IsStreamRunning(_CFG_REC_ID_1) ||
		ImageApp_MovieMulti_IsStreamRunning(_CFG_REC_ID_2) ) {		
		//if(FlowMovie_GetCurrRecTotalTime() > 3)
		{
            UISound_Play(DEMOSOUND_SOUND_SHUTTER_TONE);
            Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_RAWENC, 0);
		}
	} else {
	}
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnMovieFinish(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32  uiFolderId = 0, uiFileId = 0;
	BOOL    CheckStorageErr;
	//UINT32  gUIAviRecMaxTime;

	switch (gMovData.State) {
	case MOV_ST_REC:
	case MOV_ST_REC|MOV_ST_ZOOM:

		//#NT#2016/09/20#Bob Huang -begin
		//#NT#Support HDMI Display with 3DNR Out
		//call stop rec first before starting to rec, keep rec mode
#if (_3DNROUT_FUNC == ENABLE)
		if (!gb3DNROut)
#endif
//#NT#2016/09/20#Bob Huang -end
		{
			gMovData.State = MOV_ST_VIEW;
		}

		//#NT#2012/10/23#Philex Lin - begin
		// enable auto power off/USB detect timer
		KeyScan_EnableMisc(TRUE);
		//#NT#2012/10/23#Philex Lin - end
		FlowMovie_IconDrawMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
		UxState_SetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM, UIFlowWndMovie_Status_REC_ICON_REC_TRANSPAENT);

		//if (FlowMovie_ChkDrawStoreFullFolderFull() == FALSE)
		if (SysGetFlag(FL_MOVIE_CYCLIC_REC) == MOVIE_CYCLICREC_OFF) {
			CheckStorageErr = FlowMovie_IsStorageErr(TRUE);
		} else {
			CheckStorageErr = FlowMovie_IsStorageErr(FALSE);
		}
		if (CheckStorageErr == FALSE) {
			DCF_GetNextID(&uiFolderId, &uiFileId);
			SysSetFlag(FL_DCF_DIR_ID, uiFolderId);
			SysSetFlag(FL_DCF_FILE_ID, uiFileId);

			//#NT#2016/03/07#KCHong -begin
			//#NT#Low power timelapse function
#if (TIMELAPSE_LPR_FUNCTION == ENABLE)
			if (UI_GetData(FL_MOVIE_TIMELAPSE_REC) < TL_LPR_TIME_MIN_PERIOD)
#endif
//#NT#2016/03/07#KCHong -end
				FlowMovie_UpdateIcons(TRUE);
			Input_SetKeyMask(KEY_PRESS, MOVIE_KEY_PRESS_MASK);
		}
		break;

	//The flow here may be only for APC3 stop record than lock file function.
	//To be careful that gMovData have changed in UIFlowMovie_Stop.
	case MOV_ST_VIEW:
		// Enable key if user pressed shutter2 key to stop recording.
		Input_SetKeyMask(KEY_PRESS, MOVIE_KEY_PRESS_MASK);
		break;
	}

	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnMovieOneSec(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	switch (gMovData.State) {
	case MOV_ST_REC:
	case MOV_ST_REC|MOV_ST_ZOOM:
		if (paramNum) {
			if (UxState_GetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM) == UIFlowWndMovie_Status_REC_ICON_REC_TRANSPAENT) {
				UxState_SetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM, UIFlowWndMovie_Status_REC_ICON_REC_ELLIPSE);
			} else {
				UxState_SetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM, UIFlowWndMovie_Status_REC_ICON_REC_TRANSPAENT);
			}
			FlowMovie_IconHideMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
			FlowMovie_SetRecCurrTime(paramArray[0]);
			FlowMovie_IconDrawRecTime(&UIFlowWndMovie_Static_timeCtrl);
		}
		if (0)//(UxCtrl_IsShow(&UIFlowWndMovie_StaticIcon_PIMCCtrl))
		{
			FlowMovie_DrawPIM(FALSE);
		}

		if(gDelayCrash&& paramArray[0] >= 2)
		{
		   gDelayCrash = FALSE;
		   FlowMovie_SetCrash();
		}
		
		if(LED_IsLEDOn(GPIOMAP_LED_MOVIE))
			LED_TurnOffLED(GPIOMAP_LED_MOVIE);
		else
			LED_TurnOnLED(GPIOMAP_LED_MOVIE);
		
		break;
	}
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnMovieFull(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return UIFlowWndMovie_OnLoopRecFull(pCtrl, paramNum, paramArray);
}

INT32 UIFlowWndMovie_OnMovieWrError(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{CHKPNT;
	if ((gMovData.State == MOV_ST_REC) || (gMovData.State == (MOV_ST_REC | MOV_ST_ZOOM))) {
		FlowMovie_StopRec();
		if (System_GetState(SYS_STATE_CARD)  == CARD_LOCKED) {
			gMovData.State = MOV_ST_WARNING_MENU;
			Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_LOCKED, FLOWWRNMSG_TIMER_3SEC);
			return NVTEVT_CONSUME;
		} else {
			gMovData.State = MOV_ST_WARNING_MENU;
			Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_MEMORYERROR, FLOWWRNMSG_TIMER_3SEC);
			return NVTEVT_CONSUME;
		}
	} else {
		Input_SetKeyMask(KEY_PRESS, MOVIE_KEY_PRESS_MASK);
	}
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnStorageSlow(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	// trigger re-start encoding
#if 0
	return UIFlowWndMovie_OnExeRecord(pCtrl, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
#else
//#NT#2015/11/24#KS Hung -begin
//#NT#SMediaRec and FileSys have new method for slow card
//Movie_SetSDSlow(TRUE);
#if _TODO
	MovRec_EnableOverlap(FALSE);
#endif
//#NT#2015/11/24#KS Hung -end
#if defined(_KEY_METHOD_4KEY_)
	Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
#else
	Ux_PostEvent(NVTEVT_KEY_SELECT, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
#endif
	return NVTEVT_CONSUME;
#endif
}

INT32 UIFlowWndMovie_OnLoopRecFull(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	FlowMovie_StopRec();
	KeyScan_EnableMisc(TRUE);
	//gMovData.State = MOV_ST_VIEW;
	gMovData.State = MOV_ST_WARNING_MENU;
	Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_CARD_FULL, FLOWWRNMSG_TIMER_2SEC);
	FlowMovie_IconDrawMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnEMRCompleted(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
CHKPNT;
#if (__DBGLVL__ >= 6)
	UINT32  uiPathId = 0;

	if (paramNum)
	{
		uiPathId = paramArray[0];
	}

	DBG_IND("EMR(%d) completed!\r\n", uiPathId);
#endif
	if((paramNum == 2)&&(paramArray[1] == MOVIE_USER_CB_EVENT_EMR_FILE_COMPLETED))
	{
		DBG_IND("EMR(%d) completed!\r\n", uiPathId);
		//FlowMovie_DrawLock(FALSE);
	}
	else if((paramNum == 2)&&(paramArray[1] == MOVIE_USER_CB_EVENT_CARSH_FILE_COMPLETED))
	{
		DBG_IND("Crash (%d) completed!\r\n", uiPathId);
		//FlowMovie_DrawLock(FALSE);
	}
	
	g_bRecordLock = FALSE;
	FlowMovie_DrawLock(FALSE);
	
	return NVTEVT_CONSUME;
}

#if 0
INT32 UIFlowWndMovie_OnPreviewStable(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	ide_enable_video(IDE_VIDEOID_1);
	switch (gMovData.State) {
	case MOV_ST_VIEW:
		FlowMovie_UpdateIcons(TRUE);
		break;
	}
	return NVTEVT_CONSUME;
}
#endif

INT32 UIFlowWndMovie_OnStorageInit(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (CALIBRATION_FUNC == ENABLE)
		// check if enter engineer mode
		if (EngineerMode_CheckEng())
		{
			//cal_system_init();
			//#NT#2016/06/23#Niven Cho -begin
			//#NT#Enter calibration by cgi event or command event
			Ux_PostEvent(NVTEVT_KEY_CALIBRATION, 0);
			//#NT#2016/06/23#Niven Cho -end
		}
#endif
//#NT#2016/03/02#Niven Cho -begin
//#NT#Fix FAST_BOOT + LINUX + without card, boot failed.
#if defined(_CPU2_LINUX_)
	if (UIStorageCheck(STORAGE_CHECK_ERROR, NULL) == TRUE) {
		Ux_OpenWindow(&UIFlowWndWrnMsgCtrl, 2, UIFlowWndWrnMsg_StatusTXT_Msg_STRID_PLEASE_INSERT_SD, FLOWWRNMSG_TIMER_KEEP);
	}
#endif
//#NT#2016/03/02#Niven Cho -end
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnOZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnDZoomStepChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	FlowMovie_IconDrawDZoom(&UIFlowWndMovie_Zoom_StaticCtrl);
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnPreviewStable(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	UINT32 uiEvent;
	if (paramNum > 0) {
		uiEvent = paramArray[0];
		if (uiEvent != NVTEVT_ALGMSG_PREVIEW_STABLE) {
			return NVTEVT_CONSUME;
		}
	} else {
		return NVTEVT_CONSUME;
	}
	switch (gMovData.State) {
	case MOV_ST_VIEW:
		//#NT#2016/03/07#KCHong -begin
		//#NT#Low power timelapse function
#if (TIMELAPSE_LPR_FUNCTION == ENABLE)
		if (UI_GetData(FL_MOVIE_TIMELAPSE_REC) < TL_LPR_TIME_MIN_PERIOD)
#endif
//#NT#2016/03/07#KCHong -end
			FlowMovie_UpdateIcons(TRUE);
		break;
	}

	g_PreviewStable = TRUE;
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnStorageChange(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	FlowMovie_UpdateIcons(TRUE);

	Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyPress);
	Input_SetKeyMask(KEY_PRESS, g_uiMaskKeyRelease);

#if (SDHOTPLUG_FUNCTION == ENABLE)
	Ux_PostEvent(NVTEVT_SYSTEM_MODE, 1, System_GetState(SYS_STATE_CURRMODE));
#endif

	return NVTEVT_CONSUME;
}

#if (GPS_FUNCTION == ENABLE)
inline static void  UIFlowWndMovie_UpdateSpeedData(void)
{

	RMCINFO RMCInfo;
	GPSRec_GetRMCDate(&RMCInfo);
    #if (LOG_DBGINFO_IN_GPS_SECTION == ENABLE)
	mp4log_AddLog(0, (char *)&RMCInfo, sizeof(RMCINFO));
    #else   // #if (LOG_DBGINFO_IN_GPS_SECTION == ENABLE)
	memcpy(&(gpsdata.rmcinfo), &RMCInfo, sizeof(RMCINFO));
    #endif  // #if (LOG_DBGINFO_IN_GPS_SECTION == ENABLE)

#if 0
	debug_msg("lati:%1f, NS:%c, longi:%1f,EW:%c\r\n", gpsdata.rmcinfo.Latitude, gpsdata.rmcinfo.NSInd, gpsdata.rmcinfo.Longitude, gpsdata.rmcinfo.EWInd);
#endif
}
#endif

////pqw
static BOOL    bMotionDetRec = FALSE; // TRUE: trigger record by MD
static UINT32  uiMotionDetRet = 0;
BOOL GetMotionRecStatus(void)
{
	return bMotionDetRec;
}
void SetMotionRecStatus(BOOL status)
{
	bMotionDetRec =  status;
	if(!bMotionDetRec)
		uiMotionDetRet = FALSE;
}
////
static void UIFlowWndMovie_OnMotionDetect(void)
{
	static UINT32  uiMotionDetGo = 0;
	static UINT32  uiMotionDetStop = 0;

	//#NT#2016/11/01#Adam Su -begin
	//#NT#fix mantis issue 0106933
	//static BOOL    bMotionDetRec = FALSE; // TRUE: trigger record by MD
	//#NT#2016/11/01#Adam Su -end

	//#NT#2016/10/18#Jeah Yen -begin
	//#NT#move code to support sensor map
	//static UINT32  uiMotionDetRet = 0;
	if(!bMotionDetRec)//pqw
		Ux_SendEvent(0, NVTEVT_EXE_MOTION_DET_RUN, 1, (UINT32)&uiMotionDetRet);
	if (uiMotionDetRet == TRUE)
		//#NT#2016/10/18#Jeah Yen -end
	{
		uiMotionDetGo++;
		if (uiMotionDetGo >= 2) {
			uiMotionDetStop = 0;
			// Recording of modtion detection in pure CarDV path
			if (!((gMovData.State == MOV_ST_REC) || (gMovData.State == (MOV_ST_REC | MOV_ST_ZOOM)))) {
				// reset uiMotionDetGo
				uiMotionDetGo = 0;
				//#NT#2016/11/01#Adam Su -begin
				//#NT#fix mantis issue 0106933
				bMotionDetRec = TRUE;
				uiMotionDetRet = FALSE;
				//#NT#2016/11/01#Adam Su -end
				// press key to record video
#if defined(_KEY_METHOD_4KEY_)
				Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
#else
				Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
#endif
				 
			}
		}
	} else {
//#NT#2016/11/01#Adam Su -begin
//#NT#fix mantis issue 0106933
		if (bMotionDetRec == TRUE) {
			uiMotionDetStop++;
			if (uiMotionDetStop >= 2) { // 1 sec
				uiMotionDetGo = 0;
			}
			DBGD(uiMotionDetStop);
			//if (uiMotionDetStop >= 20) { // 10 Sec
			//	uiMotionDetStop = 0;
			if (uiMotionDetStop >= 62) { //pqw 30 Sec
				uiMotionDetStop = 0;
				if (FlowMovie_GetRecCurrTime() >= 1) {
// CardDV path
					if (gMovData.State == MOV_ST_REC || gMovData.State == (MOV_ST_REC | MOV_ST_ZOOM)) 
					{
						FlowMovie_StopRec();
						// update ui window icon
						FlowMovie_UpdateIcons(TRUE);
						bMotionDetRec = FALSE;
					}
				}
			}
		}
//#NT#2016/11/01#Adam Su -end
	}
}

//#MT#zjf -20200922 -begin
#if (ETHCAM_TX_UPDATE_TEST == ENABLE)

#if (defined(_NVT_ETHREARCAM_RX_))
#include "FileSysTsk.h"
#include "EthCamAppCmd.h"
#include "UIModeUpdFw.h"
#include "UIFlow.h"
#include "EthCamAppSocket.h"
#include "EthCamSocket.h"

static BOOL Ethcam_tx_fwupdate(void)
{
	UINT32 uiFwAddr, uiFwSize;
	FST_FILE hFile;
	static char uiUpdateFWName[64] ="A:\\FW671_AA.bin" ;//"FW671_AA";// "A:\\EthcamTxFW.bin";
	INT32 fst_er;
	UINT32 EthCamCmdRET=0;

    BOOL bRet = FALSE;
	//Ux_CloseWindow(&UIFlowWndWaitMomentCtrl, 0);
	//CHKPNT;
	//Ux_OpenWindow(&UIFlowWndWaitMomentCtrl, 1, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_ETHCAM_UDFW_SENDFW);

    
	EthCam_SendXMLCmd(ETHCAM_PATH_ID_1, ETHCAM_PORT_DATA1 ,ETHCAM_CMD_TX_STREAM_STOP, 0);
#if (ETH_REARCAM_CLONE_FOR_DISPLAY == ENABLE)
	EthCam_SendXMLCmd(ETHCAM_PATH_ID_1, ETHCAM_PORT_DATA2 ,ETHCAM_CMD_TX_STREAM_STOP, 0);
#endif
	Delay_DelayMs(500);  
	System_ChangeSubMode(SYS_SUBMODE_UPDFW);
	Ux_SendEvent(0, NVTEVT_SYSTEM_MODE, 1, PRIMARY_MODE_UPDFW);

	uiFwSize = (UINT32)FileSys_GetFileLen(uiUpdateFWName);
	uiFwAddr = OS_GetMempoolAddr(POOL_ID_APP);

	hFile = FileSys_OpenFile(uiUpdateFWName, FST_OPEN_READ);
	if (hFile != 0) {
		fst_er = FileSys_ReadFile(hFile, (UINT8 *)uiFwAddr, &uiFwSize, 0, NULL);
		FileSys_CloseFile(hFile);
		if (fst_er != FST_STA_OK) {
			DBG_ERR("FW bin read fail\r\n");
			//return TRUE;
			bRet = FALSE;
            return bRet;
		}
	}
	DBG_DUMP("Total FwSize=%d\r\n",uiFwSize);

	EthCamSocketCli_SetCmdSendSizeCB(ETHCAM_PATH_ID_1, (UINT32)&socketCliEthCmd_SendSizeCB);
	EthCam_SendXMLCmd(ETHCAM_PATH_ID_1, ETHCAM_PORT_DEFAULT ,ETHCAM_CMD_TX_FWUPDATE_FWSEND, uiFwSize);
	EthCamCmdRET=EthCam_SendXMLData(ETHCAM_PATH_ID_1, (UINT8 *)uiFwAddr, uiFwSize);
	EthCamSocketCli_SetCmdSendSizeCB(ETHCAM_PATH_ID_1, 0);

	if(EthCamCmdRET==ETHCAM_RET_OK){
        bRet = TRUE;
		DBG_DUMP("Send FW update  Start\r\n");
		EthCam_SendXMLCmd(ETHCAM_PATH_ID_1, ETHCAM_PORT_DEFAULT ,ETHCAM_CMD_TX_FWUPDATE_START, 0);
	}else{
        bRet = FALSE;
		DBG_ERR("FW send error, %d\r\n",EthCamCmdRET);
	}
	Ux_CloseWindow(&UIFlowWndWaitMomentCtrl, 0);//0616
	//Ux_OpenWindow(&UIFlowWndWaitMomentCtrl, 1, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_ETHCAM_UDFW_START);
//	FileSys_DeleteFile("A:\\EthcamTxFW.bin");//MT CJ 2020/420  mv to EthCamAppNetwork.c
	return bRet;
}

//static 
BOOL Ethcam_tx_DetFwAutoUpdate(void)
{
    FST_FILE filehdl;
    BOOL bRet = FALSE;

    FileSys_WaitFinish();
    filehdl = FileSys_OpenFile("A:\\FW671_AA.bin",FST_OPEN_READ);
    if(filehdl == NULL)
    {
        //TESTLOG("txupdate  fail, no update file");
       // debug_msg("mmmmm not del update FW\r\n");
    }
    else
    {
    	if ( gMovData.State == MOV_ST_REC )
        {

			FlowMovie_StopRec();
	}
       // TESTLOG("txupdate");
       FileSys_CloseFile(filehdl);
	   CHKPNT;
	//Ux_OpenWindow(&UIFlowWndWaitMomentCtrl, 1, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_ETHCAM_UDFW_SENDFW);
	Delay_DelayMs(200);
        bRet = Ethcam_tx_fwupdate();
    }
    return bRet;
}
#endif
#endif
//#MT#lyb -20200922 -end


//static UINT8 Check_TX_Update_Cnt = 0; 
extern void System_UpdateTx(void );
BOOL bAutoRecFirstTime = FALSE;
BOOL bPlaybackChangeModeAutoRec = FALSE;
extern void  EnableSynGpsStatus(void);
INT32 UIFlowWndMovie_OnTimer(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	//#NT#2016/03/07#KCHong -begin
	//#NT#Low power timelapse function
#if (TIMELAPSE_LPR_FUNCTION == ENABLE)
	UINT32 TLRet = 0;
	static UINT32 Cnt = 0;
#endif
//#NT#2016/03/07#KCHong -end

#if (GPS_FUNCTION == ENABLE)
	static UINT32 GPSHeartBeatPrev = 0, GPSHeartBeatNow = 0;
#endif
	UINT32  uiEvent;
	uiEvent = paramNum ? paramArray[0] : 0;
	switch (uiEvent) {
    	case NVTEVT_01SEC_TIMER:
        	if(g_uiRecStopTimerCnt){
        	    g_uiRecStopTimerCnt--;
        	    if(g_uiRecStopTimerCnt==0){
        	        if (g_UIStopRecTimerID != NULL_TIMER) {
                		GxTimer_StopTimer(&g_UIStopRecTimerID);
        	        }
        	        //Ux_OpenWindow(&UIFlowWndWaitMomentCtrl, 1, UIFlowWndWaitMoment_StatusTXT_Msg_STRID_STOPREC_WAIT);
        	        break;
        	    }
        	}
    	    break;
	case NVTEVT_05SEC_TIMER:
//#NT#2016/03/07#KCHong -begin
//#NT#Low power timelapse function
#if (TIMELAPSE_LPR_FUNCTION == ENABLE)
		TLRet = MovieTLLPR_Process(TIMELAPSE_FROM_TIMER);
		if ((TLRet & TL_FLOW_MASK) == TL_FLOW_LPR) {
			if ((TLRet & TL_STATE_MASK) == TL_STATE_RECORD) {
// flash REC icon one time to indicate capturing
				if (UxState_GetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM) == UIFlowWndMovie_Status_REC_ICON_REC_TRANSPAENT) {
					Cnt ++;
				}

				if (Cnt == 2) {
					Cnt = 0;
					UxState_SetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM, UIFlowWndMovie_Status_REC_ICON_REC_ELLIPSE);
				}
				FlowMovie_IconHideMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
				FlowMovie_IconDrawRecTime(&UIFlowWndMovie_Static_timeCtrl);
			} else {
				UxState_SetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM, UIFlowWndMovie_Status_REC_ICON_REC_TRANSPAENT);
				FlowMovie_IconDrawMaxRecTime(&UIFlowWndMovie_Static_maxtimeCtrl);
			}
		}
#endif
//#NT#2016/03/07#KCHong -end

#if (AUTO_WIFI==ENABLE)
		{
			static BOOL autoWifi = FALSE;

			if (!autoWifi) {
				//#NT#2016/03/23#Isiah Chang -begin
				//#NT#add new Wi-Fi UI flow.
#if(WIFI_UI_FLOW_VER == WIFI_UI_VER_1_0)
				//Ux_OpenWindow(&UIMenuWndWiFiWaitCtrl, 0);
#endif
//#NT#2016/03/23#Isiah Chang -end
               if(!System_GetGsensorPwrOn())//park mode,do not open wifi
			   {
				   	if (UI_GetData(FL_WIFI) == WIFI_ON)
				   	{
						BKG_PostEvent(NVTEVT_BKW_WIFI_ON);
						//UISound_Play(DEMOSOUND_SOUND_WIFI_ON_TONE);
						UI_SetData(FL_WIFI_LINK, WIFI_LINK_OK);
						FlowMovie_IconDrawWifi(&UIFlowWndMovie_Status_WIFICtrl);

						autoWifi = TRUE;
				   	}
			   }
           }
		}
#endif
		//if (System_GetState(SYS_STATE_CARD)  == CARD_INSERTED && Check_TX_Update_Cnt<6){	//3s	//MT zjf 20200922
		//	DBGD(Check_TX_Update_Cnt);
			//Check_TX_Update_Cnt++;
			System_UpdateTx();
			//Delay_DelayMs(100);
		//}



		//get GPS/GSensor Data
		//#NT#2013/3/20#Philex Lin-begin
#if (GPS_FUNCTION == ENABLE)
#if (LOG_DBGINFO_IN_GPS_SECTION == DISABLE)
		UIFlowWndMovie_UpdateSpeedData();
#endif  // #if (LOG_DBGINFO_IN_GPS_SECTION == DISABLE)
		g_GPSStatus = GPSRec_GetSpeed(&g_CurSpeed);
		EnableSynGpsStatus();
#endif  // #if (GPS_FUNCTION == ENABLE)
//#NT#2013/3/20#Philex Lin-end

		// Do Motion detect process
		if (g_uiRecordIngMotionDet == TRUE) {
			UIFlowWndMovie_OnMotionDetect();
		}
#if( defined(_NVT_ETHREARCAM_TX_) && AV_LCA_FUNC == ENABLE)

		AVLCA_VEHICLE_INFO VehicleInfo={0};
		AV_GetLCAVehicleInfo(&VehicleInfo);
		if(VehicleInfo.iVehicleNum){
			UINT8 i;
			for(i=0;i<VehicleInfo.iVehicleNum;i++){
				DBG_DUMP("VehicleNum[%d]=[%d][%d,%d,%d,%d]\r\n",VehicleInfo.iVehicleNum,i,VehicleInfo.iVehicleRect[i].x,VehicleInfo.iVehicleRect[i].y,VehicleInfo.iVehicleRect[i].w,VehicleInfo.iVehicleRect[i].h) ;
			}
		}
		AVLCA_WARNING_RESULT WarnRslt={0};
		AV_GetLCAWarnRslt(&WarnRslt);
		if(WarnRslt.LWarnStatus || WarnRslt.RWarnStatus){
			DBG_DUMP("LWarnSta=%d, RWarnSta%d\r\n",WarnRslt.LWarnStatus,WarnRslt.RWarnStatus) ;
		}
#endif
		break;

	case NVTEVT_1SEC_TIMER:
		if(g_wifi_info_show)//MT pqw add:after 60s,wifi info display
		{ 
			static UINT32 wifi_info_show_time = 0;
			wifi_info_show_time++;
			if(wifi_info_show_time>=60)
			{
				g_wifi_info_show = 0;
				wifi_info_show_time = 0;
			}
		}
		#if 1//(_VERSON_TYPE_ == _VERSON_RST_NORMAL_ || _VERSON_TYPE_ == _VERSON_RST_ADT_)
		if(bEnterTimelapse)//缩时录影10秒后自动关屏
		{
			UIFlowWndMovie_AutoBackLightOff();
		}
		#endif
		
		//#NT#2015/10/02#KCHong -begin
		//#NT#For GPS & ADAS
#if (GPS_FUNCTION == ENABLE)
		GPSHeartBeatNow = GetGPSHeartBeat();
		g_GPSLinked = (GPSHeartBeatNow != GPSHeartBeatPrev) ? TRUE : FALSE;
		GPSHeartBeatPrev = GPSHeartBeatNow;
#endif
//#NT#2015/10/02#KCHong -end

#if (_ADAS_FUNC_ == ENABLE)
		if (UxCtrl_IsShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl)) {
			g_uiAdasAlertSecCnt++;
			if (g_uiAdasAlertSecCnt == 2) {
				UxCtrl_SetShow(&UIFlowWndMovie_Panel_Normal_DisplayCtrl, TRUE);
				UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl, FALSE);
				g_uiAdasAlertSecCnt = 0;
			} else {
				return NVTEVT_CONSUME;
			}
		}
#endif  // #if (_ADAS_FUNC_ == ENABLE)

		if (g_bDelayUpdateIcon) {
			FlowMovie_UpdateIcons(TRUE);
			g_bDelayUpdateIcon = FALSE;
		}

		if(bEnterTimelapse == TRUE){
			if (UxState_GetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM) == UIFlowWndMovie_Status_REC_ICON_REC_TRANSPAENT) {
				UxState_SetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM, UIFlowWndMovie_Status_REC_ICON_REC_ELLIPSE);
			} else {
				UxState_SetData(&UIFlowWndMovie_Status_RECCtrl, STATE_CURITEM, UIFlowWndMovie_Status_REC_ICON_REC_TRANSPAENT);
			}
		}


		FlowMovie_OnTimer1SecIndex();
		// Isiah, implement YUV merge mode of recording func.
#if _TODO
		if (MovRec_IsRecording()) {
			Ux_SendEvent(&CustomMovieObjCtrl, NVTEVT_EXE_MOVIE_REC_STEP, 0);
		}
#endif

	//DBGD(bAutoRecFirstTime);
	//DBGD(bPlaybackChangeModeAutoRec);
    if((!bAutoRecFirstTime) || bPlaybackChangeModeAutoRec)
    {
       bPlaybackChangeModeAutoRec = FALSE;
       bAutoRecFirstTime = TRUE;
        if(gMovData.State == MOV_ST_VIEW ||
            gMovData.State == (MOV_ST_VIEW | MOV_ST_ZOOM))
        {
            if(System_GetGsensorPwrOn())//parking rec
            {
                if (!FlowMovie_IsStorageErr(FALSE)) {
		            System_SetParkPwroffTimeCount(60);	
					CHKPNT;
					gbNoNeedVocieNotice = TRUE;
					FlowMovie_DrawLock(TRUE);
                    //Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
					Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 2, NVTEVT_KEY_PRESS,UIFlowWndMovieRecordCrash);
                } else {
                    System_SetParkPwroffTimeCount(5);     
                }
            }
            else if(!bDemoStart)//normal rec
            {
                Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
            }
        }
    }
	
#if (MOVIE_AUTOREC_ACPLUG == ENABLE)
		if (System_GetState(SYS_STATE_POWERON) == SYSTEM_POWERON_SAFE) {
			//if (!MovRec_IsRecording()) {
				if (g_PreviewStable_Record == FALSE) {
					if ((g_ACPlug == TRUE) && (g_PreviewStable == TRUE)) {
//if (g_PreviewStable == TRUE)
						g_PreviewStable_Record = TRUE;
#if defined(_KEY_METHOD_4KEY_)
						Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);
#else
						Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
#endif
					}
				}
			//}
		}
#endif
		break;
	}
	Ux_DefaultEvent(pCtrl, NVTEVT_TIMER, paramNum, paramArray);
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnACPlug(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (MOVIE_AUTOREC_ACPLUG == ENABLE)
	g_ACPlug = TRUE;
// start record if receiving preview stable event
	if ((g_PreviewStable == TRUE) && (g_PreviewStable_Record == FALSE)) {
		g_PreviewStable_Record = TRUE;
		if (UI_GetData(FL_WIFI_AUTO_RECORDING) == WIFI_AUTO_RECORDING_ON) {
//Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
		}
	}
#endif
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnACUnplug(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	g_ACPlug = FALSE;
	//Ux_PostEvent(NVTEVT_KEY_SELECT, 1, NVTEVT_KEY_PRESS);
	return NVTEVT_CONSUME;
}

INT32 UIFlowWndMovie_OnCustom1(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	if (SysGetFlag(FL_GSENSOR) != GSENSOR_OFF) {
		if ((gMovData.State == MOV_ST_REC) || (gMovData.State == MOV_ST_REC_WAIT)) {
			if (SysGetFlag(FL_MOVIE_URGENT_PROTECT_AUTO) == MOVIE_URGENT_PROTECT_AUTO_ON) {
				if (GetMovieRecType_2p(UI_GetData(FL_MOVIE_SIZE)) == MOVIE_REC_TYPE_FRONT) {
#if(defined(_NVT_ETHREARCAM_RX_))
					ImageApp_MovieMulti_SetCrash(_CFG_REC_ID_1, TRUE);
					UINT32 i;
					for (i = 0; i < ETH_REARCAM_CAPS_COUNT; i++) {
						if(socketCliEthData1_IsRecv(ETHCAM_PATH_ID_1 +i)){
							ImageApp_MovieMulti_SetCrash(_CFG_ETHCAM_ID_1+i, TRUE);
						}
					}
#else
					ImageApp_MovieMulti_TrigEMR(_CFG_REC_ID_1);
#endif
				} else {
					UINT32 i, mask, movie_rec_mask;

 					movie_rec_mask = Movie_GetMovieRecMask();
					mask = 1;
					for (i = 0; i < SENSOR_CAPS_COUNT; i++) {
						if (movie_rec_mask & mask) {
							ImageApp_MovieMulti_SetCrash(_CFG_REC_ID_1 + i, TRUE);
						}
						mask <<= 1;
					}
				}
			}
		}
	}

	return NVTEVT_CONSUME;
}

#if (WIFI_UI_DIRECT_MOBILE_LINKOK == ENABLE)
INT32 UIFlowWndMovie_OnWifiAuthorizeOK(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{CHKPNT;
CHKPNT;
CHKPNT;
CHKPNT;
CHKPNT;
	if (System_GetState(SYS_STATE_CURRSUBMODE) != SYS_SUBMODE_WIFI)
	{ 
        if (gUIMotionDetTimerID != NULL_TIMER) {
            GxTimer_StopTimer(&gUIMotionDetTimerID);
        }
        
        if (g_uiDateTimerID != NULL_TIMER) {
            GxTimer_StopTimer(&g_uiDateTimerID);
        }
        
        if (g_UIStopRecTimerID != NULL_TIMER) {
            GxTimer_StopTimer(&g_UIStopRecTimerID);
        }
		System_ChangeToWifiMode();
	}
	return NVTEVT_CONSUME;
}
#endif
INT32 UIFlowWndMovie_OnADASShowAlarm(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (_ADAS_FUNC_ == ENABLE)
	UINT32 AlarmType;
	ADAS_APPS_RESULT_INFO *pAdasRlt = MovieExe_GetAdasRltOSD();

	Ux_FlushEventByRange(NVTEVT_CB_ADAS_SHOWALARM, NVTEVT_CB_ADAS_SHOWALARM);
	AlarmType = paramArray[0];

	switch (AlarmType) {
	case ADAS_ALARM_LD:
		g_uiAdasAlertSecCnt = 0;
		UISound_Play(DEMOSOUND_SOUND_LDWS_TONE);
		if (!UxCtrl_IsShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl)) {
			UxCtrl_SetShow(&UIFlowWndMovie_Panel_Normal_DisplayCtrl, FALSE);
			UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl, TRUE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl, TRUE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_FCWS_AlertCtrl, FALSE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_SNG_AlertCtrl, FALSE);
			switch (pAdasRlt->LdwsRsltInfo.DepartureDirSound) {
			case LDWS_DEPARTURE_LEFT:
				UxState_SetData(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl, STATE_CURITEM, UIFlowWndMovie_StatusICN_LDWS_Alert_ICON_LDWS_LEFT_ALERT);
				break;
			case LDWS_DEPARTURE_RIGHT:
				UxState_SetData(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl, STATE_CURITEM, UIFlowWndMovie_StatusICN_LDWS_Alert_ICON_LDWS_RIGHT_ALERT);
				break;
			default:
				break;
			}
		}
		break;

	case ADAS_ALARM_FC:
		g_uiAdasAlertSecCnt = 0;
		UISound_Play(DEMOSOUND_SOUND_FCS_TONE);
		if (!UxCtrl_IsShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl)) {
			UxCtrl_SetShow(&UIFlowWndMovie_Panel_Normal_DisplayCtrl, FALSE);
			UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl, TRUE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl, FALSE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_FCWS_AlertCtrl, TRUE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_SNG_AlertCtrl, FALSE);

			if ((pAdasRlt->FcwsRsltInfo.uiKelDist < 15) && (pAdasRlt->FcwsRsltInfo.uiKelDist > 0)) {
				UxState_SetData(&UIFlowWndMovie_StatusICN_FCWS_AlertCtrl, STATE_CURITEM, UIFlowWndMovie_StatusICN_FCWS_Alert_ICON_FCW_FAR_ALERT);
			}
		}
		break;

	case ADAS_ALARM_GO:
		g_uiAdasAlertSecCnt = 0;
		UISound_Play(DEMOSOUND_SOUND_SNG_TONE);
		if (!UxCtrl_IsShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl)) {
			UxCtrl_SetShow(&UIFlowWndMovie_Panel_Normal_DisplayCtrl, FALSE);
			UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl, TRUE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl, FALSE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_FCWS_AlertCtrl, FALSE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_SNG_AlertCtrl, TRUE);
			UxState_SetData(&UIFlowWndMovie_StatusICN_SNG_AlertCtrl, STATE_CURITEM, UIFlowWndMovie_StatusICN_SNG_Alert_ICON_SNG_ALERT);
		}
		break;

	case ADAS_ALARM_STOP:
		g_uiAdasAlertSecCnt = 0;
		UISound_Play(DEMOSOUND_SOUND_SNG_TONE);
		if (!UxCtrl_IsShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl)) {
			UxCtrl_SetShow(&UIFlowWndMovie_Panel_Normal_DisplayCtrl, FALSE);
			UxCtrl_SetShow(&UIFlowWndMovie_ADAS_Alert_DisplayCtrl, TRUE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_LDWS_AlertCtrl, FALSE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_FCWS_AlertCtrl, FALSE);
			UxCtrl_SetShow(&UIFlowWndMovie_StatusICN_SNG_AlertCtrl, TRUE);
			UxState_SetData(&UIFlowWndMovie_StatusICN_SNG_AlertCtrl, STATE_CURITEM, UIFlowWndMovie_StatusICN_SNG_Alert_ICON_SNG_ALERT);
		}
		break;

	default:
		break;
	}
#endif  // #if (_ADAS_FUNC_ == ENABLE)
	return NVTEVT_CONSUME;
}

//#NT#2016/07/20#Brain Yen -begin
//#NT#Add for DDD alarm
INT32 UIFlowWndMovie_OnDDDShowAlarm(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (_DDD_FUNC_ == ENABLE)
	UINT32 AlarmType;
	AlarmType = paramArray[0];
#if 0//Add for test
	GxSound_SetOutDevConfigIdx(0);
#endif
	switch (AlarmType) {
	case DDD_ALARM_PERCLOS:
		UISound_Play(DEMOSOUND_SOUND_DDDWARNING3_TONE);
		break;

	case DDD_ALARM_YAWN:
		UISound_Play(DEMOSOUND_SOUND_DDDWARNING3_TONE);
		break;

	case DDD_ALARM_DIS:
		UISound_Play(DEMOSOUND_SOUND_DDDWARNING2_TONE);
		break;

	case DDD_ALARM_NODE:
		UISound_Play(DEMOSOUND_SOUND_DDDWARNING3_TONE);
		break;

	case DDD_ALARM_EYE:
		UISound_Play(DEMOSOUND_SOUND_DDDWARNING1_TONE);
		break;

	default:
		break;
	}
#endif
	return NVTEVT_CONSUME;
}
//#NT#2016/07/20#Brain Yen -end

//#NT#2016/06/23#Niven Cho -begin
//#NT#Enter calibration by cgi event or command event
INT32 UIFlowWndMovie_OnKeyCalibration(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if (CALIBRATION_FUNC == ENABLE)
	{
		Ux_SendEvent(0, NVTEVT_SYSTEM_MODE, 1, PRIMARY_MODE_MAIN);
		EngineerMode_Open();
	}
#endif
	return NVTEVT_CONSUME;

}
//#NT#2016/06/23#Niven Cho -end
INT32 UIFlowWndMovie_OnOverTime(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
#if defined(_KEY_METHOD_4KEY_)
	Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
#else
	Ux_PostEvent(NVTEVT_KEY_SELECT, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
#endif
	return NVTEVT_CONSUME;
}
INT32 UIFlowWndMovie_OnBackgroundDone(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
	NVTEVT event=paramArray[ONDONE_PARAM_INDEX_CMD];
	//UINT32 status= paramArray[ONDONE_PARAM_INDEX_RET];

	debug_ind(("UIFlowWndMovie_OnBackgroundDone event = 0x%x\r\n", event));

	switch (event) {
	case NVTEVT_BKW_STOPREC_PROCESS: {
		    g_uiRecStopTimerCnt=0;
		    FlowMovie_UpdateIcons(TRUE);

		}
		break;
	default:
		break;
	}

	return NVTEVT_CONSUME;

}
extern UINT8 EthcamTx_Timelapse;
INT32 UIFlowWndMovie_OnEnterAccOffTimelapse(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{CHKPNT;
    BOOL CheckStorageErr;
	if( SysGetFlag(FL_MOVIE_CYCLIC_REC) == MOVIE_CYCLICREC_OFF )
	{
		CheckStorageErr = FlowMovie_IsStorageErr(TRUE);
	} 
	else 
	{
		CheckStorageErr = FlowMovie_IsStorageErr(FALSE);
	}
    if(CheckStorageErr)
    {
        debug_msg("^GLiwk ------ Card error ... Power off!!!\r\n");
        Ux_PostEvent(NVTEVT_KEY_POWER_REL, 1, NVTEVT_KEY_RELEASE);		
		return NVTEVT_CONSUME;
    }
	
	//ide_setTvPowerDown(TRUE);
		
    bEnterTimelapse = TRUE;

	if (UI_GetData(FL_WIFI_LINK) == WIFI_LINK_OK) {
		Ux_SendEvent(0,NVTEVT_EXE_WIFI_STOP, 0);
	}

	FlowMovie_IconDrawWifi(&UIFlowWndMovie_Status_WIFICtrl);

	if (SysGetFlag(FL_MOVIE_TIMELAPSE_REC)==MOVIE_TIMELAPSEREC_OFF){
		SysSetFlag(FL_MOVIE_TIMELAPSE_REC,MOVIE_TIMELAPSEREC_1SEC);
	}
		CHKPNT;
#if 0
	EthCamCmd_GetFrameTimerEn(0);
	//ImageApp_MovieMulti_EthCamLinkForDisp((_CFG_ETHCAM_ID_1 ), DISABLE, TRUE);
	if(socketCliEthData1_IsRecv(ETHCAM_PATH_ID_1)){
		EthCam_SendXMLCmd(ETHCAM_PATH_ID_1, ETHCAM_PORT_DATA1 ,ETHCAM_CMD_TX_STREAM_STOP, 0);
	}
#if (ETH_REARCAM_CLONE_FOR_DISPLAY == ENABLE)
	if(socketCliEthData2_IsRecv(ETHCAM_PATH_ID_1)){
		EthCam_SendXMLCmd(ETHCAM_PATH_ID_1, ETHCAM_PORT_DATA2 ,ETHCAM_CMD_TX_STREAM_STOP, 0);
	}
#endif
	EthCamCmd_Done(ETHCAM_PATH_ID_1, 0xFFFFFFFF, ETHCAM_CMD_TERMINATE);
	EthCamSocketCli_ReConnect(ETHCAM_PATH_ID_1, 0, 0);

	EthCam_SendXMLCmd(ETHCAM_PATH_ID_1,ETHCAM_PORT_DEFAULT,ETHCAM_CMD_TX_ENTER_TIMELAPSE,SysGetFlag(FL_MOVIE_TIMELAPSE_REC));

	EthCamCmd_GetFrameTimerEn(1);
#if(ETH_REARCAM_CLONE_FOR_DISPLAY == ENABLE)
	EthCam_SendXMLCmd(ETHCAM_PATH_ID_1, ETHCAM_PORT_DATA2 ,ETHCAM_CMD_TX_STREAM_START, 0);
#endif
	EthCam_SendXMLCmd(ETHCAM_PATH_ID_1, ETHCAM_PORT_DATA1 ,ETHCAM_CMD_TX_STREAM_START, 0);
	EthCamNet_SetPrevEthLinkStatus(ETHCAM_PATH_ID_1, ETHCAM_LINK_UP);

#endif
	EthCam_SendXMLCmd(ETHCAM_PATH_ID_1,ETHCAM_PORT_DEFAULT,ETHCAM_CMD_TX_ENTER_TIMELAPSE,SysGetFlag(FL_MOVIE_TIMELAPSE_REC));

	//Ux_PostEvent(NVTEVT_SYSTEM_MODE, 1, System_GetState(SYS_STATE_CURRMODE));
	#if 1
    if(gMovData.State == MOV_ST_REC ){
        Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 3, NVTEVT_KEY_PRESS, 0, UIFlowWndMovie_Restart_Rec);
    }else{
        Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);  
    }
	#endif
	
	return NVTEVT_CONSUME;
}
UINT32 gTimelapse_Is_need_Reboot = FALSE;
INT32 UIFlowWndMovie_OnExitAccOffTimelapse(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{CHKPNT;
	//CHAR noticecmd[40]  = {0};
    //BOOL CheckStorageErr;
    bEnterTimelapse = FALSE;
	gTimelapse_Is_need_Reboot= TRUE;
	//if (g_UIStopRecTimerID != NULL_TIMER) {
   //     GxTimer_StopTimer(&g_UIStopRecTimerID);
   // }
	//ide_setTvPowerDown(FALSE);

    if (0)//(UI_GetData(FL_WIFI_LINK) != WIFI_LINK_OK)
    {
        //#if(WIFI_UI_FLOW_VER == WIFI_UI_VER_1_0)
        //#if(WIFI_UI_DIRECT_MOBILE_LINKOK == ENABLE)
           BKG_PostEvent(NVTEVT_BKW_WIFI_ON);
        //#endif
        //#endif
        //UISound_Play(DEMOSOUND_SOUND_WIFI_ON_TONE);
		SysSetFlag(FL_AUTO_WIFI,AUTO_WIFI_ON);
		FlowMovie_IconDrawWifi(&UIFlowWndMovie_Status_WIFICtrl);
    }


	if(UIFlowWndMovie_GetLcdBacklightStus() == FALSE)
		UIFlowWndMovie_LcdBackLightCrl(TRUE);
	
	if (SysGetFlag(FL_MOVIE_TIMELAPSE_REC)!=MOVIE_TIMELAPSEREC_OFF)
		SysSetFlag(FL_MOVIE_TIMELAPSE_REC,MOVIE_TIMELAPSEREC_OFF);
	
	EthCam_SendXMLCmd(ETHCAM_PATH_ID_1,ETHCAM_PORT_DEFAULT,ETHCAM_CMD_TX_EXIT_TIMELAPSE,SysGetFlag(FL_MOVIE_TIMELAPSE_REC));
	
	#if 1//(_VERSON_TYPE_ == _VERSON_RST_NORMAL_ || _VERSON_TYPE_ == _VERSON_RST_ADT_)
	{
		if(gMovData.State == MOV_ST_REC )
	    {
	        Ux_PostEvent(NVTEVT_KEY_SHUTTER2, 1, NVTEVT_KEY_PRESS);  
	    }
		//Set_TimelapsereRebootStatus(TRUE);
		//Save_MenuInfo();		
		//snprintf(noticecmd, 40, "EthRestart %d %d", ipstr2int(SocketInfo[0].ip),ETHCAM_LINK_DOWN);
		//EthCamNet_EthLinkStatusNotify(noticecmd);
		 //GxSystem_HWResetNOW();
		CHKPNT;
		//gpio_setDir(P_GPIO_24, GPIO_DIR_OUTPUT);
		//gpio_clearPin(P_GPIO_24);
		//else if(Get_TimelapsereRebootStatus())
		//{	Set_TimelapsereRebootStatus(FALSE);
		//	CHKPNT;
		//	BKG_PostEvent(NVTEVT_BKW_ETHCAM_SOCKETCLI_CMD_OPEN);
		//}
		  Sys_AutoReboot(20);
		  //GxSystem_EnableSWReset(0);
		  //Delay_DelayMs(3000);
		CHKPNT;
		//GxSystem_EnableHWReset(0);
        //GxSystem_EnableSWReset(bEnterTimelapse);
		//DBG_DUMP(" System start power off !!!(%d)   \r\n",__LINE__);
		//GxSystem_PowerOff();
		//Ux_PostEvent(NVTEVT_SYSTEM_SHUTDOWN, 1, 0);
		  //System_PowerOff(SYS_POWEROFF_NORMAL);
	}
	#endif
	
	return NVTEVT_CONSUME;
}

//---------------------UIFlowWndMovie_Panel_Normal_DisplayCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_Panel_Normal_Display)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_camera)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_CyclicRec)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_MotionDet)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_battery)
CTRL_LIST_ITEM(UIFlowWndMovie_YMD_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_HMS_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_REC)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Storage)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_time)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_maxtime)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_resolution)
CTRL_LIST_ITEM(UIFlowWndMovie_Zoom_Static)
CTRL_LIST_ITEM(UIFlowWndMovie_StatusICN_EV)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_HDR)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_WIFI)
CTRL_LIST_ITEM(UIFlowWndMovie_StaticIcon_PIMC)
CTRL_LIST_ITEM(UIFlowWndMovie_ADAS_DrawingLine)
///#NT#2016/06/08#Lincy Lin -begin
//#NT#Implement generic OSD and video drawing mechanism for ALG function
CTRL_LIST_ITEM(UIFlowWndMovie_ALG_Draw)
//#NT#2016/06/08#Lincy Lin -end
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Parking)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_MicroPhone)
CTRL_LIST_ITEM(UIFlowWndMovie_Static_CardFreeCapacity)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Lock)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Snap)
CTRL_LIST_ITEM(UIFlowWndMovie_StaticTXT_SSID)
CTRL_LIST_ITEM(UIFlowWndMovie_StaticTXT_Key)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_Gsensor)
CTRL_LIST_ITEM(UIFlowWndMovie_Status_GPS)
CTRL_LIST_END

//----------------------UIFlowWndMovie_Panel_Normal_DisplayCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Panel_Normal_Display)
EVENT_END

//----------------------UIFlowWndMovie_Static_cameraCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_camera)
EVENT_END

//----------------------UIFlowWndMovie_Status_CyclicRecCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_CyclicRec)
EVENT_END

//----------------------UIFlowWndMovie_Status_MotionDetCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_MotionDet)
EVENT_END

//----------------------UIFlowWndMovie_Status_batteryCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_battery)
EVENT_END

//----------------------UIFlowWndMovie_YMD_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_YMD_Static)
EVENT_END

//----------------------UIFlowWndMovie_HMS_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_HMS_Static)
EVENT_END

//----------------------UIFlowWndMovie_Status_RECCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_REC)
EVENT_END

//----------------------UIFlowWndMovie_Status_StorageCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Storage)
EVENT_END

//----------------------UIFlowWndMovie_Static_timeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_time)
EVENT_END

//----------------------UIFlowWndMovie_Static_maxtimeCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_maxtime)
EVENT_END

//----------------------UIFlowWndMovie_Static_resolutionCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_resolution)
EVENT_END

//----------------------UIFlowWndMovie_Zoom_StaticCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Zoom_Static)
EVENT_END

//----------------------UIFlowWndMovie_StatusICN_EVCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StatusICN_EV)
EVENT_END

//----------------------UIFlowWndMovie_Status_HDRCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_HDR)
EVENT_END

//----------------------UIFlowWndMovie_Status_WIFICtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_WIFI)
EVENT_END

//----------------------UIFlowWndMovie_StaticIcon_PIMCCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StaticIcon_PIMC)
EVENT_END

//#NT#2016/06/08#Lincy Lin -begin
//#NT#Implement generic OSD and video drawing mechanism for ALG function

//---------------------UIFlowWndMovie_ADAS_DrawingLineCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_ADAS_DrawingLine)
CTRL_LIST_END

//----------------------UIFlowWndMovie_ADAS_DrawingLineCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_ADAS_DrawingLine)
EVENT_END

//---------------------UIFlowWndMovie_ALG_DrawCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_ALG_Draw)
CTRL_LIST_END
//----------------------UIFlowWndMovie_ALG_DrawCtrl Event---------------------------
INT32 UIFlowWndMovie_ALG_Draw_OnRedraw(VControl *, UINT32, UINT32 *);
EVENT_BEGIN(UIFlowWndMovie_ALG_Draw)
EVENT_ITEM(NVTEVT_REDRAW, UIFlowWndMovie_ALG_Draw_OnRedraw)
EVENT_END

INT32 UIFlowWndMovie_ALG_Draw_OnRedraw(VControl *pCtrl, UINT32 paramNum, UINT32 *paramArray)
{
    return UIFlowWndMovie_ALG_Draw_OSD(pCtrl, paramNum, paramArray);
}

//----------------------UIFlowWndMovie_Status_ParkingCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Parking)
EVENT_END

//----------------------UIFlowWndMovie_Status_MicroPhoneCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_MicroPhone)
EVENT_END

//----------------------UIFlowWndMovie_Static_CardFreeCapacityCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Static_CardFreeCapacity)
EVENT_END

//----------------------UIFlowWndMovie_Status_LockCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Lock)
EVENT_END

//----------------------UIFlowWndMovie_Status_SnapCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Snap)
EVENT_END

//----------------------UIFlowWndMovie_StaticTXT_SSIDCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StaticTXT_SSID)
EVENT_END

//----------------------UIFlowWndMovie_StaticTXT_KeyCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StaticTXT_Key)
EVENT_END

//----------------------UIFlowWndMovie_Status_GsensorCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_Gsensor)
EVENT_END 

//----------------------UIFlowWndMovie_Status_GPSCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_Status_GPS)
EVENT_END

//---------------------UIFlowWndMovie_ADAS_Alert_DisplayCtrl Control List---------------------------
CTRL_LIST_BEGIN(UIFlowWndMovie_ADAS_Alert_Display)
CTRL_LIST_ITEM(UIFlowWndMovie_StatusICN_LDWS_Alert)
CTRL_LIST_ITEM(UIFlowWndMovie_StatusICN_FCWS_Alert)
CTRL_LIST_ITEM(UIFlowWndMovie_StatusICN_SNG_Alert)
CTRL_LIST_END

//----------------------UIFlowWndMovie_ADAS_Alert_DisplayCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_ADAS_Alert_Display)
EVENT_END

//----------------------UIFlowWndMovie_StatusICN_LDWS_AlertCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StatusICN_LDWS_Alert)
EVENT_END

//----------------------UIFlowWndMovie_StatusICN_FCWS_AlertCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StatusICN_FCWS_Alert)
EVENT_END

//----------------------UIFlowWndMovie_StatusICN_SNG_AlertCtrl Event---------------------------
EVENT_BEGIN(UIFlowWndMovie_StatusICN_SNG_Alert)
EVENT_END

